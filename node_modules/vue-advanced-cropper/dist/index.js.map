{"version":3,"file":"index.js","sources":["../node_modules/classnames/index.js","../node_modules/easy-bem/index.js","../node_modules/debounce/index.js","../node_modules/tslib/tslib.es6.js","../src/core/utils.ts","../src/core/events.ts","../node_modules/rollup-plugin-vue/node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/components/service/DraggableElement.vue","../src/mixins/draggable.js","../src/core/constants.ts","../src/core/service.ts","../src/core/algorithms/approximatedSize.ts","../src/core/algorithms/move.ts","../src/core/algorithms/applyTransform.ts","../src/core/algorithms/autoZoom.ts","../src/core/algorithms/defaultSize.ts","../src/core/algorithms/limitBy.ts","../src/core/algorithms/manipulateImage.ts","../src/core/algorithms/rotateImage.ts","../src/core/algorithms/flipImage.ts","../src/core/algorithms/resize.ts","../src/components/handlers/SimpleHandler.vue","../src/core/image.ts","../src/components/service/PreviewResult.vue","../src/core/touch.ts","../src/components/service/CropperWrapper.vue","../src/Cropper.vue","../src/core/algorithms/defaultPosition.ts","../src/core/algorithms/defaultVisibleArea.ts","../src/core/algorithms/initStretcher.ts","../src/core/algorithms/fitCoordinates.ts","../src/core/algorithms/fitVisibleArea.ts","../src/core/algorithms/areaRestrictions.ts","../src/core/algorithms/sizeRestrictions.ts","../src/core/algorithms/positionRestrictions.ts","../src/core/algorithms/refineSizeRestrictions.ts","../src/core/algorithms/roundCoordinates.ts","../src/core/algorithms/normalizeEvent.ts","../src/core/canvas.ts","../src/core/algorithms/defaultBoundaries.ts","../src/core/algorithms/refineVisibleArea.ts","../src/core/algorithms/stencil.ts","../src/index.js"],"sourcesContent":["/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","'use strict';\r\n\r\n/**\r\n * BEM class name factory.\r\n *\r\n * @typedef {Function} Bem\r\n * @param {String|Object} [elementOrMods] Element name or hash object with mods\r\n * @param {Object} [mods] Hash object with mods\r\n * @returns {String}\r\n */\r\n\r\n/**\r\n * Returns BEM class name factory.\r\n *\r\n * @param {String} componentName Block name\r\n * @returns {Bem}\r\n */\r\nmodule.exports = function bem(componentName) {\r\n    return function (elementOrMods, mods) {\r\n        if (!elementOrMods) {\r\n            return componentName;\r\n        }\r\n\r\n        var element;\r\n\r\n        if (typeof elementOrMods === 'string') {\r\n            element = elementOrMods;\r\n        } else {\r\n            mods = elementOrMods;\r\n        }\r\n\r\n        var base = componentName;\r\n        if (element) {\r\n            base += '__' + element;\r\n        }\r\n\r\n        return base + (\r\n            mods\r\n                ? Object.keys(mods).reduce(function (result, name) {\r\n                    var value = mods[name];\r\n\r\n                    if (value) {\r\n                        result += ' ' + (\r\n                            typeof value === 'boolean'\r\n                                ? (base + '--' + name)\r\n                                : (base + '--' + name + '_' + value)\r\n                        );\r\n                    }\r\n\r\n                    return result;\r\n                }, '')\r\n                : ''\r\n        );\r\n    };\r\n}\r\n","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","type Protocol = 'http' | 'https';\r\n\r\nexport function directionNames(hDirection, vDirection) {\r\n\tlet name, classname;\r\n\tif (hDirection && vDirection) {\r\n\t\tname = `${hDirection}${vDirection[0].toUpperCase()}${vDirection.slice(1)}`;\r\n\t\tclassname = `${hDirection}-${vDirection}`;\r\n\t} else {\r\n\t\tname = hDirection || vDirection;\r\n\t\tclassname = hDirection || vDirection;\r\n\t}\r\n\treturn { name, classname };\r\n}\r\n\r\nexport function isBlob(url: string) {\r\n\treturn /^blob:/.test(url);\r\n}\r\n\r\nexport function isDataUrl(url: string) {\r\n\treturn /^data:/.test(url);\r\n}\r\n\r\nexport function isLocal(url: string) {\r\n\treturn isBlob(url) || isDataUrl(url);\r\n}\r\n\r\nexport function isCrossOriginURL(url: string) {\r\n\tif (isLocal(url)) {\r\n\t\treturn false;\r\n\t}\r\n\tconst pageLocation = window.location;\r\n\tconst URL_HOST_PATTERN = /(\\w+:)?(?:\\/\\/)([\\w.-]+)?(?::(\\d+))?\\/?/;\r\n\tconst urlMatch = URL_HOST_PATTERN.exec(url) || [];\r\n\tconst urlparts = {\r\n\t\tprotocol: urlMatch[1] || '',\r\n\t\thost: urlMatch[2] || '',\r\n\t\tport: urlMatch[3] || '',\r\n\t};\r\n\r\n\tconst defaultPort = (protocol: Protocol) => {\r\n\t\tif (protocol === 'http') {\r\n\t\t\treturn 80;\r\n\t\t} else {\r\n\t\t\treturn 433;\r\n\t\t}\r\n\t};\r\n\r\n\tconst portOf = (location: any) => {\r\n\t\treturn location.port || defaultPort((location.protocol || pageLocation.protocol) as Protocol);\r\n\t};\r\n\r\n\treturn !(\r\n\t\t(!urlparts.protocol && !urlparts.host && !urlparts.port) ||\r\n\t\tBoolean(\r\n\t\t\turlparts.protocol &&\r\n\t\t\t\turlparts.protocol == pageLocation.protocol &&\r\n\t\t\t\turlparts.host &&\r\n\t\t\t\turlparts.host == pageLocation.host &&\r\n\t\t\t\turlparts.host &&\r\n\t\t\t\tportOf(urlparts) == portOf(pageLocation),\r\n\t\t)\r\n\t);\r\n}\r\n\r\nexport function isFunction(obj: any) {\r\n\treturn !!(obj && obj.constructor && obj.call && obj.apply);\r\n}\r\n\r\nexport function isUndefined(obj: any): boolean {\r\n\treturn obj === undefined;\r\n}\r\n\r\nexport function isObject(obj) {\r\n\treturn typeof obj === 'object' && obj !== null;\r\n}\r\n\r\nexport function getOptions(options: any, defaultScheme: any, falseScheme: any) {\r\n\tconst result: any = {};\r\n\tif (isObject(options)) {\r\n\t\tObject.keys(defaultScheme).forEach((key) => {\r\n\t\t\tif (isUndefined(options[key])) {\r\n\t\t\t\tresult[key] = defaultScheme[key];\r\n\t\t\t} else if (isObject(defaultScheme[key])) {\r\n\t\t\t\tif (isObject(options[key])) {\r\n\t\t\t\t\tresult[key] = getOptions(options[key], defaultScheme[key], falseScheme[key]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult[key] = options[key] ? defaultScheme[key] : falseScheme[key];\r\n\t\t\t\t}\r\n\t\t\t} else if (defaultScheme[key] === true || defaultScheme[key] === false) {\r\n\t\t\t\tresult[key] = Boolean(options[key]);\r\n\t\t\t} else {\r\n\t\t\t\tresult[key] = options[key];\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn result;\r\n\t} else {\r\n\t\tif (options) {\r\n\t\t\treturn defaultScheme;\r\n\t\t} else {\r\n\t\t\treturn falseScheme;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function getSettings<T extends {}>(param, defaultParams?: T) {\r\n\tlet result = {\r\n\t\tenabled: Boolean(param),\r\n\t\t...defaultParams,\r\n\t};\r\n\tif (isObject(param)) {\r\n\t\tresult = { ...result, ...param };\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nexport function parseNumber(number) {\r\n\tconst parsedNumber = Number(number);\r\n\tif (Number.isNaN(parsedNumber)) {\r\n\t\treturn number;\r\n\t} else {\r\n\t\treturn parsedNumber;\r\n\t}\r\n}\r\n\r\nexport function replacedProp(value, oldName, currentName) {\r\n\tif (!isEmpty(value) && process.env.NODE_ENV !== 'production') {\r\n\t\tconsole.warn(`Warning: prop \"${oldName}\" is deprecated, use \"${currentName}\" instead. Value:`, value);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nexport function isEmpty(obj) {\r\n\treturn (!obj || Object.keys(obj).length === 0) && typeof obj !== 'function';\r\n}\r\n\r\nexport function isObjectLike(value) {\r\n\treturn typeof value === 'object' && value !== null;\r\n}\r\n\r\nexport function isNumber(value) {\r\n\treturn (\r\n\t\ttypeof (value == 'number' || (isObjectLike(value) && toString.call(value) == '[object Number]')) &&\r\n\t\t!isNaN(value)\r\n\t);\r\n}\r\n\r\nexport function isNumeric(value) {\r\n\treturn !Number.isNaN(parseFloat(value)) && isFinite(value);\r\n}\r\n\r\nexport function isNaN(value) {\r\n\treturn value !== value;\r\n}\r\n\r\nexport function isLoadedImage(image) {\r\n\treturn Boolean(image.naturalWidth);\r\n}\r\n\r\nexport function distance(firstPoint, secondPoint) {\r\n\treturn Math.sqrt(Math.pow(firstPoint.x - secondPoint.x, 2) + Math.pow(firstPoint.y - secondPoint.y, 2));\r\n}\r\n\r\nexport function isApproximatelyEqual(a: number, b: number, precision = 0.001) {\r\n\tif (a === 0 || b === 0) {\r\n\t\treturn Math.abs(b - a) < precision;\r\n\t} else {\r\n\t\treturn Math.abs(b / a) < 1 + precision && Math.abs(b / a) > 1 - precision;\r\n\t}\r\n}\r\n\r\nexport function sign(value) {\r\n\tconst number = +value;\r\n\tif (number === 0 || isNaN(number)) {\r\n\t\treturn number;\r\n\t}\r\n\treturn number > 0 ? 1 : -1;\r\n}\r\n\r\nexport function radians(angle: number) {\r\n\treturn (angle * Math.PI) / 180;\r\n}\r\n","import { StencilEvent, Diff, MoveDirections, Point, ResizeDirections, Scale } from './typings';\r\n\r\nexport class ManipulateImageEvent implements StencilEvent {\r\n\ttype: 'manipulateImage';\r\n\tnativeEvent: Event;\r\n\tmove: Partial<MoveDirections>;\r\n\tscale: Partial<Scale>;\r\n\tconstructor(move: Partial<MoveDirections> = {}, scale: Partial<Scale> = {}) {\r\n\t\tthis.type = 'manipulateImage';\r\n\t\tthis.move = move;\r\n\t\tthis.scale = scale;\r\n\t}\r\n}\r\n\r\nexport interface ResizeEventParams {\r\n\tcompensate?: boolean;\r\n\tpreserveRatio?: boolean;\r\n\tallowedDirections?: ResizeDirections;\r\n\trespectDirection?: 'width' | 'height';\r\n}\r\n\r\nexport class ResizeEvent implements StencilEvent {\r\n\ttype: 'resize';\r\n\tdirections: ResizeDirections;\r\n\tparams: ResizeEventParams;\r\n\r\n\tconstructor(directions: ResizeDirections, params: ResizeEventParams = {}) {\r\n\t\tthis.type = 'resize';\r\n\t\tthis.directions = directions;\r\n\t\tthis.params = params;\r\n\t}\r\n}\r\n\r\nexport class MoveEvent implements StencilEvent {\r\n\ttype: 'move';\r\n\tdirections: MoveDirections;\r\n\r\n\tconstructor(directions: MoveDirections) {\r\n\t\tthis.type = 'move';\r\n\t\tthis.directions = directions;\r\n\t}\r\n}\r\n\r\nexport class DragEvent implements StencilEvent {\r\n\ttype: 'drag';\r\n\tnativeEvent: Event;\r\n\tposition: Point;\r\n\tpreviousPosition: Point;\r\n\tanchor: Point;\r\n\telement: HTMLElement;\r\n\r\n\tconstructor(nativeEvent: Event, element: HTMLElement, position: Point, previousPosition: Point, anchor: Point) {\r\n\t\tthis.type = 'drag';\r\n\t\tthis.nativeEvent = nativeEvent;\r\n\t\tthis.position = position;\r\n\t\tthis.previousPosition = previousPosition;\r\n\t\tthis.element = element;\r\n\t\tthis.anchor = anchor;\r\n\t}\r\n\tpublic shift(): Diff {\r\n\t\tconst { element, anchor, position } = this;\r\n\t\tconst { left, top } = element.getBoundingClientRect();\r\n\r\n\t\treturn {\r\n\t\t\tleft: position.left - left - anchor.left,\r\n\t\t\ttop: position.top - top - anchor.top,\r\n\t\t};\r\n\t}\r\n}\r\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","<script>\r\nimport draggable from '../../mixins/draggable';\r\n\r\nexport default {\r\n\tname: 'DraggableElement',\r\n\tmixins: [draggable],\r\n\tprops: {\r\n\t\tclassname: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<div\r\n\t\tref=\"draggable\"\r\n\t\t:class=\"classname\"\r\n\t\t@touchstart=\"onTouchStart\"\r\n\t\t@mousedown=\"onMouseDown\"\r\n\t\t@mouseover=\"onMouseOver\"\r\n\t\t@mouseleave=\"onMouseLeave\"\r\n\t>\r\n\t\t<slot />\r\n\t</div>\r\n</template>\r\n","import { DragEvent } from '../core/events';\n\nexport default {\n\tbeforeMount() {\n\t\twindow.addEventListener('mouseup', this.onMouseUp, { passive: false });\n\t\twindow.addEventListener('mousemove', this.onMouseMove, { passive: false });\n\t\twindow.addEventListener('touchmove', this.onTouchMove, { passive: false });\n\t\twindow.addEventListener('touchend', this.onTouchEnd, { passive: false });\n\t},\n\tbeforeDestroy() {\n\t\twindow.removeEventListener('mouseup', this.onMouseUp);\n\t\twindow.removeEventListener('mousemove', this.onMouseMove);\n\t\twindow.removeEventListener('touchmove', this.onTouchMove);\n\t\twindow.removeEventListener('touchend', this.onTouchEnd);\n\t},\n\tmounted() {\n\t\tif (!this.$refs.draggable) {\n\t\t\tthrow new Error('You should add ref \"draggable\" to your root element to use draggable mixin');\n\t\t}\n\t\tthis.touches = [];\n\t\tthis.hovered = false;\n\t},\n\tmethods: {\n\t\tonMouseOver() {\n\t\t\tif (!this.hovered) {\n\t\t\t\tthis.hovered = true;\n\t\t\t\tthis.$emit('enter');\n\t\t\t}\n\t\t},\n\t\tonMouseLeave() {\n\t\t\tif (this.hovered && !this.touches.length) {\n\t\t\t\tthis.hovered = false;\n\t\t\t\tthis.$emit('leave');\n\t\t\t}\n\t\t},\n\t\tonTouchStart(e) {\n\t\t\tif (e.cancelable && !this.disabled && e.touches.length === 1) {\n\t\t\t\tthis.touches = [...e.touches];\n\n\t\t\t\tif (!this.hovered) {\n\t\t\t\t\tthis.$emit('enter');\n\t\t\t\t\tthis.hovered = true;\n\t\t\t\t}\n\n\t\t\t\tif (e.touches.length) {\n\t\t\t\t\tthis.initAnchor(\n\t\t\t\t\t\tthis.touches.reduce(\n\t\t\t\t\t\t\t(mean, touch) => {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tclientX: mean.clientX + touch.clientX / e.touches.length,\n\t\t\t\t\t\t\t\t\tclientY: mean.clientY + touch.clientY / e.touches.length,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{ clientX: 0, clientY: 0 },\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (e.preventDefault) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tonTouchEnd() {\n\t\t\tthis.processEnd();\n\t\t},\n\t\tonTouchMove(e) {\n\t\t\tif (this.touches.length) {\n\t\t\t\tthis.processMove(e, e.touches);\n\t\t\t\tif (e.preventDefault) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t\tif (e.stopPropagation) {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonMouseDown(e) {\n\t\t\tif (!this.disabled && e.button === 0) {\n\t\t\t\tconst touch = {\n\t\t\t\t\tfake: true,\n\t\t\t\t\tclientX: e.clientX,\n\t\t\t\t\tclientY: e.clientY,\n\t\t\t\t};\n\t\t\t\tthis.touches = [touch];\n\t\t\t\tthis.initAnchor(touch);\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tonMouseMove(e) {\n\t\t\tif (this.touches.length) {\n\t\t\t\tthis.processMove(e, [\n\t\t\t\t\t{\n\t\t\t\t\t\tfake: true,\n\t\t\t\t\t\tclientX: e.clientX,\n\t\t\t\t\t\tclientY: e.clientY,\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tif (e.preventDefault) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonMouseUp() {\n\t\t\tthis.processEnd();\n\t\t},\n\t\tinitAnchor(touch) {\n\t\t\tconst draggable = this.$refs.draggable;\n\t\t\tconst { left, right, bottom, top } = draggable.getBoundingClientRect();\n\n\t\t\tthis.anchor = {\n\t\t\t\tleft: touch.clientX - left,\n\t\t\t\ttop: touch.clientY - top,\n\t\t\t\tbottom: bottom - touch.clientY,\n\t\t\t\tright: right - touch.clientX,\n\t\t\t};\n\t\t},\n\t\tprocessMove(event, touches) {\n\t\t\tconst newTouches = [...touches];\n\t\t\tif (this.touches.length) {\n\t\t\t\tif (this.touches.length === 1 && newTouches.length === 1) {\n\t\t\t\t\tconst element = this.$refs.draggable;\n\t\t\t\t\tthis.$emit(\n\t\t\t\t\t\t'drag',\n\t\t\t\t\t\tnew DragEvent(\n\t\t\t\t\t\t\tevent,\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tleft: newTouches[0].clientX,\n\t\t\t\t\t\t\t\ttop: newTouches[0].clientY,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tleft: this.touches[0].clientX,\n\t\t\t\t\t\t\t\ttop: this.touches[0].clientY,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tthis.anchor,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthis.touches = newTouches;\n\t\t\t}\n\t\t},\n\t\tprocessEnd() {\n\t\t\tif (this.touches.length) {\n\t\t\t\tthis.$emit('drag-end');\n\t\t\t}\n\t\t\tif (this.hovered) {\n\t\t\t\tthis.$emit('leave');\n\t\t\t\tthis.hovered = false;\n\t\t\t}\n\t\t\tthis.touches = [];\n\t\t},\n\t},\n};\n","import { HorizontalDirection, PositionDirection, VerticalDirection, MainDirections } from './typings';\r\n\r\nexport const ALL_DIRECTIONS: PositionDirection[] = ['left', 'right', 'top', 'bottom'];\r\nexport const HORIZONTAL_DIRECTIONS: HorizontalDirection[] = ['left', 'right'];\r\nexport const VERTICAL_DIRECTIONS: VerticalDirection[] = ['top', 'bottom'];\r\nexport const MAIN_DIRECTIONS: MainDirections[] = ['left', 'top'];\r\nexport const IMAGE_RESTRICTIONS = ['fill-area', 'fit-area', 'stencil', 'none'];\r\nexport const XHR_DONE = 4;\r\n\r\nexport const DEFAULT_COORDINATES = {\r\n\tleft: 0,\r\n\ttop: 0,\r\n\twidth: 0,\r\n\theight: 0,\r\n};\r\n","import {\r\n\tAspectRatio,\r\n\tCoordinates,\r\n\tDiff,\r\n\tIntersections,\r\n\tLimits,\r\n\tMoveDirections,\r\n\tPoint,\r\n\tResizeDirections,\r\n\tSize,\r\n\tSizeRestrictions,\r\n} from './typings';\r\nimport { ALL_DIRECTIONS } from './constants';\r\n\r\nexport function isEqual(a: any, b: any, properties?: string[]): boolean {\r\n\tproperties = properties || ['width', 'height', 'left', 'top'];\r\n\treturn !properties.some((property) => a[property] !== b[property]);\r\n}\r\n\r\nexport function toLimits(object: Coordinates): Limits {\r\n\treturn {\r\n\t\tleft: object.left,\r\n\t\ttop: object.top,\r\n\t\tright: object.left + object.width,\r\n\t\tbottom: object.top + object.height,\r\n\t};\r\n}\r\n\r\nexport function diff(firstObject: Point, secondObject: Point): Diff {\r\n\treturn {\r\n\t\tleft: firstObject.left - secondObject.left,\r\n\t\ttop: firstObject.top - secondObject.top,\r\n\t};\r\n}\r\n\r\nexport function getCenter(object: Coordinates): Point {\r\n\treturn {\r\n\t\tleft: object.left + object.width / 2,\r\n\t\ttop: object.top + object.height / 2,\r\n\t};\r\n}\r\n\r\nexport function getIntersections(object: Coordinates, limits: Limits): Intersections {\r\n\tconst intersections: Intersections = {\r\n\t\tleft: 0,\r\n\t\ttop: 0,\r\n\t\tright: 0,\r\n\t\tbottom: 0,\r\n\t};\r\n\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\tconst areaLimit = limits[direction];\r\n\t\tconst objectLimit = toLimits(object)[direction];\r\n\t\tif (areaLimit !== undefined && objectLimit !== undefined) {\r\n\t\t\tif (direction === 'left' || direction === 'top') {\r\n\t\t\t\tintersections[direction] = Math.max(0, areaLimit - objectLimit);\r\n\t\t\t} else {\r\n\t\t\t\tintersections[direction] = Math.max(0, objectLimit - areaLimit);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tintersections[direction] = 0;\r\n\t\t}\r\n\t});\r\n\treturn intersections;\r\n}\r\n\r\nexport function applyDirections(coordinates: Coordinates, directions: ResizeDirections): Coordinates {\r\n\treturn {\r\n\t\tleft: coordinates.left - directions.left,\r\n\t\ttop: coordinates.top - directions.top,\r\n\t\twidth: coordinates.width + directions.left + directions.right,\r\n\t\theight: coordinates.height + directions.top + directions.bottom,\r\n\t};\r\n}\r\n\r\nexport function inverseMove(directions: MoveDirections): MoveDirections {\r\n\treturn {\r\n\t\tleft: -directions.left,\r\n\t\ttop: -directions.top,\r\n\t};\r\n}\r\n\r\nexport function applyMove(object: Coordinates, move: MoveDirections): Coordinates {\r\n\treturn {\r\n\t\t...object,\r\n\t\tleft: object.left + move.left,\r\n\t\ttop: object.top + move.top,\r\n\t};\r\n}\r\n\r\nexport function applyScale(object: Coordinates, scaleFactor: number, center?: Point, progress?: number): Coordinates {\r\n\tif (scaleFactor !== 1) {\r\n\t\tif (center) {\r\n\t\t\tconst currentCenter = getCenter(object);\r\n\t\t\treturn {\r\n\t\t\t\twidth: object.width * scaleFactor,\r\n\t\t\t\theight: object.height * scaleFactor,\r\n\t\t\t\tleft:\r\n\t\t\t\t\tobject.left +\r\n\t\t\t\t\t(object.width * (1 - scaleFactor)) / 2 +\r\n\t\t\t\t\t(center.left - currentCenter.left) * (progress || 1 - scaleFactor),\r\n\t\t\t\ttop:\r\n\t\t\t\t\tobject.top +\r\n\t\t\t\t\t(object.height * (1 - scaleFactor)) / 2 +\r\n\t\t\t\t\t(center.top - currentCenter.top) * (progress || 1 - scaleFactor),\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\twidth: object.width * scaleFactor,\r\n\t\t\t\theight: object.height * scaleFactor,\r\n\t\t\t\tleft: object.left + (object.width * (1 - scaleFactor)) / 2,\r\n\t\t\t\ttop: object.top + (object.height * (1 - scaleFactor)) / 2,\r\n\t\t\t};\r\n\t\t}\r\n\t} else {\r\n\t\treturn object;\r\n\t}\r\n}\r\n\r\nexport function ratio(object: Size): number {\r\n\treturn object.width / object.height;\r\n}\r\n\r\nexport function maxScale(object: Coordinates, area: Limits): number {\r\n\treturn Math.min(\r\n\t\tarea.right !== undefined && area.left !== undefined ? (area.right - area.left) / object.width : Infinity,\r\n\t\tarea.bottom !== undefined && area.top !== undefined ? (area.bottom - area.top) / object.height : Infinity,\r\n\t);\r\n}\r\n\r\n// Move object to correspond limits\r\nexport function fit(object: Coordinates, limits: Limits): MoveDirections {\r\n\tconst directions = {\r\n\t\tleft: 0,\r\n\t\ttop: 0,\r\n\t};\r\n\r\n\tconst intersection = getIntersections(object, limits);\r\n\r\n\tif (intersection.left && intersection.left > 0) {\r\n\t\tdirections.left = intersection.left;\r\n\t} else if (intersection.right && intersection.right > 0) {\r\n\t\tdirections.left = -intersection.right;\r\n\t}\r\n\tif (intersection.top && intersection.top > 0) {\r\n\t\tdirections.top = intersection.top;\r\n\t} else if (intersection.bottom && intersection.bottom > 0) {\r\n\t\tdirections.top = -intersection.bottom;\r\n\t}\r\n\r\n\treturn directions;\r\n}\r\n\r\nexport function getBrokenRatio(currentAspectRatio: number, aspectRatio: AspectRatio): number | undefined {\r\n\tlet ratioBroken;\r\n\tif (aspectRatio.minimum && currentAspectRatio < aspectRatio.minimum) {\r\n\t\tratioBroken = aspectRatio.minimum;\r\n\t} else if (aspectRatio.maximum && currentAspectRatio > aspectRatio.maximum) {\r\n\t\tratioBroken = aspectRatio.maximum;\r\n\t}\r\n\treturn ratioBroken;\r\n}\r\n\r\nexport function fitSize(firstSize: Size, secondSize: Size): Size {\r\n\tconst firstRatio = ratio(firstSize);\r\n\tconst secondRatio = ratio(secondSize);\r\n\r\n\tif (secondSize.width < Infinity && secondSize.height < Infinity) {\r\n\t\tif (firstRatio > secondRatio) {\r\n\t\t\treturn {\r\n\t\t\t\twidth: secondSize.width,\r\n\t\t\t\theight: secondSize.width / firstRatio,\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\twidth: secondSize.height * firstRatio,\r\n\t\t\t\theight: secondSize.height,\r\n\t\t\t};\r\n\t\t}\r\n\t} else if (secondSize.width < Infinity) {\r\n\t\treturn {\r\n\t\t\twidth: secondSize.width,\r\n\t\t\theight: secondSize.width / firstRatio,\r\n\t\t};\r\n\t} else if (secondSize.height < Infinity) {\r\n\t\treturn {\r\n\t\t\twidth: secondSize.height * firstRatio,\r\n\t\t\theight: secondSize.height,\r\n\t\t};\r\n\t} else {\r\n\t\treturn firstSize;\r\n\t}\r\n}\r\n\r\nexport function rotateSize(size: Size, angle: number) {\r\n\tconst radians = (angle * Math.PI) / 180;\r\n\treturn {\r\n\t\twidth: Math.abs(size.width * Math.cos(radians)) + Math.abs(size.height * Math.sin(radians)),\r\n\t\theight: Math.abs(size.width * Math.sin(radians)) + Math.abs(size.height * Math.cos(radians)),\r\n\t};\r\n}\r\n\r\nexport function rotatePoint(point: Point, angle: number) {\r\n\tconst radians = (angle * Math.PI) / 180;\r\n\treturn {\r\n\t\tleft: point.left * Math.cos(radians) - point.top * Math.sin(radians),\r\n\t\ttop: point.left * Math.sin(radians) + point.top * Math.cos(radians),\r\n\t};\r\n}\r\n\r\nexport function adjustSize(coordinates: Coordinates, area: Limits) {\r\n\tconst intersections = getIntersections(fitToLimits(coordinates, area), area);\r\n\r\n\tif (intersections.left + intersections.right + intersections.top + intersections.bottom) {\r\n\t\tif (intersections.left + intersections.right > intersections.top + intersections.bottom) {\r\n\t\t\treturn Math.min(\r\n\t\t\t\t(coordinates.width + intersections.left + intersections.right) / coordinates.width,\r\n\t\t\t\tmaxScale(coordinates, area),\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\treturn Math.min(\r\n\t\t\t\t(coordinates.height + intersections.top + intersections.bottom) / coordinates.height,\r\n\t\t\t\tmaxScale(coordinates, area),\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nexport function fitToLimits(coordinates: Coordinates, area: Limits, inverse = false) {\r\n\tconst move = fit(coordinates, area);\r\n\treturn applyMove(coordinates, inverse ? inverseMove(move) : move);\r\n}\r\n\r\nexport function limitsToSize(area: Limits) {\r\n\treturn {\r\n\t\twidth: area.right !== undefined && area.left !== undefined ? area.right - area.left : Infinity,\r\n\t\theight: area.bottom !== undefined && area.top !== undefined ? area.bottom - area.top : Infinity,\r\n\t};\r\n}\r\n\r\nexport function limitSizeRestrictions(sizeRestrictions: SizeRestrictions, object: Size) {\r\n\treturn {\r\n\t\t...sizeRestrictions,\r\n\t\tminWidth: Math.min(object.width, sizeRestrictions.minWidth),\r\n\t\tminHeight: Math.min(object.height, sizeRestrictions.minHeight),\r\n\t\tmaxWidth: Math.min(object.width, sizeRestrictions.maxWidth),\r\n\t\tmaxHeight: Math.min(object.height, sizeRestrictions.maxHeight),\r\n\t};\r\n}\r\n\r\nexport function joinLimits(a: Limits, b: Limits, intersection = true): Limits {\r\n\tconst limits: Limits = {};\r\n\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\tconst firstDirection = a[direction];\r\n\t\tconst secondDirection = b[direction];\r\n\t\tif (firstDirection !== undefined && secondDirection !== undefined) {\r\n\t\t\tif (direction === 'left' || direction === 'top') {\r\n\t\t\t\tlimits[direction] = intersection\r\n\t\t\t\t\t? Math.max(firstDirection, secondDirection)\r\n\t\t\t\t\t: Math.min(firstDirection, secondDirection);\r\n\t\t\t} else {\r\n\t\t\t\tlimits[direction] = intersection\r\n\t\t\t\t\t? Math.min(firstDirection, secondDirection)\r\n\t\t\t\t\t: Math.max(firstDirection, secondDirection);\r\n\t\t\t}\r\n\t\t} else if (secondDirection !== undefined) {\r\n\t\t\tlimits[direction] = secondDirection;\r\n\t\t} else if (firstDirection !== undefined) {\r\n\t\t\tlimits[direction] = firstDirection;\r\n\t\t}\r\n\t});\r\n\treturn limits;\r\n}\r\n\r\nexport function unionLimits(a: Limits, b: Limits) {\r\n\treturn joinLimits(a, b, false);\r\n}\r\n\r\nexport function intersectionLimits(a: Limits, b: Limits) {\r\n\treturn joinLimits(a, b, true);\r\n}\r\n","// This function returns the approximation size to width / height with respect to\r\n// restrictions and aspect ratio\r\nimport { AspectRatio, Size, SizeRestrictions } from '../typings';\r\nimport { ratio } from '../service';\r\n\r\ninterface CandidateSize extends Size {\r\n\t// Additional param to prevent double precision problems\r\n\tcorrectRatio?: boolean;\r\n}\r\n\r\ninterface ValidateSizeParams {\r\n\tsize: CandidateSize;\r\n\taspectRatio: AspectRatio;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tignoreMinimum?: boolean;\r\n}\r\nfunction validateSize(params: ValidateSizeParams): boolean {\r\n\tconst { size, aspectRatio, ignoreMinimum, sizeRestrictions } = params;\r\n\treturn Boolean(\r\n\t\t(size.correctRatio || (ratio(size) >= aspectRatio.minimum && ratio(size) <= aspectRatio.maximum)) &&\r\n\t\t\tsize.height <= sizeRestrictions.maxHeight &&\r\n\t\t\tsize.width <= sizeRestrictions.maxWidth &&\r\n\t\t\tsize.width &&\r\n\t\t\tsize.height &&\r\n\t\t\t(ignoreMinimum || (size.height >= sizeRestrictions.minHeight && size.width >= sizeRestrictions.minWidth)),\r\n\t);\r\n}\r\n\r\nfunction distance(a: Size, b: Size): number {\r\n\treturn Math.pow(a.width - b.width, 2) + Math.pow(a.height - b.height, 2);\r\n}\r\n\r\n// Limitations:\r\n// 1. Assume that maximum width and height always larger than minimum width and height\r\n// 2. Assume that aspectRatio.minimum < aspectRatio.maximum\r\n// If you break this limitations function could return null!\r\ninterface ApproximatedSizeParams {\r\n\twidth: number;\r\n\theight: number;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\taspectRatio?: AspectRatio;\r\n}\r\nexport function approximatedSize(params: ApproximatedSizeParams): Size {\r\n\tconst { width, height, sizeRestrictions } = params;\r\n\r\n\tconst aspectRatio = {\r\n\t\tminimum: (params.aspectRatio && params.aspectRatio.minimum) || 0,\r\n\t\tmaximum: (params.aspectRatio && params.aspectRatio.maximum) || Infinity,\r\n\t};\r\n\r\n\tconst coordinates = {\r\n\t\twidth: Math.max(sizeRestrictions.minWidth, Math.min(sizeRestrictions.maxWidth, width)),\r\n\t\theight: Math.max(sizeRestrictions.minHeight, Math.min(sizeRestrictions.maxHeight, height)),\r\n\t};\r\n\r\n\tfunction findBestCandidate(candidates: CandidateSize[], ignoreMinimum = false): CandidateSize | null {\r\n\t\treturn candidates.reduce<CandidateSize | null>((minimum: CandidateSize | null, size: CandidateSize) => {\r\n\t\t\tif (validateSize({ size, aspectRatio, sizeRestrictions, ignoreMinimum })) {\r\n\t\t\t\treturn !minimum || distance(size, { width, height }) < distance(minimum, { width, height })\r\n\t\t\t\t\t? size\r\n\t\t\t\t\t: minimum;\r\n\t\t\t} else {\r\n\t\t\t\treturn minimum;\r\n\t\t\t}\r\n\t\t}, null);\r\n\t}\r\n\r\n\tconst candidates: CandidateSize[] = [];\r\n\r\n\tif (aspectRatio) {\r\n\t\t[aspectRatio.minimum, aspectRatio.maximum].forEach((ratio) => {\r\n\t\t\tif (ratio) {\r\n\t\t\t\tcandidates.push(\r\n\t\t\t\t\t{ width: coordinates.width, height: coordinates.width / ratio, correctRatio: true },\r\n\t\t\t\t\t{ width: coordinates.height * ratio, height: coordinates.height, correctRatio: true },\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tif (validateSize({ size: coordinates, aspectRatio, sizeRestrictions })) {\r\n\t\tcandidates.push(coordinates);\r\n\t}\r\n\r\n\tconst candidate = findBestCandidate(candidates) || findBestCandidate(candidates, true);\r\n\r\n\treturn (\r\n\t\tcandidate && {\r\n\t\t\twidth: candidate.width,\r\n\t\t\theight: candidate.height,\r\n\t\t}\r\n\t);\r\n}\r\n","import { MoveEvent } from '../events';\r\nimport { Coordinates, PositionRestrictions } from '../typings';\r\nimport { applyMove, fit } from '../service';\r\n\r\nexport interface MoveParams {\r\n\tevent: MoveEvent;\r\n\tcoordinates: Coordinates;\r\n\tpositionRestrictions: PositionRestrictions;\r\n}\r\n\r\nexport function move(params: MoveParams): Coordinates {\r\n\tconst { event, coordinates, positionRestrictions = {} } = params;\r\n\r\n\tconst movedCoordinates = applyMove(coordinates, event.directions);\r\n\r\n\treturn applyMove(movedCoordinates, fit(movedCoordinates, positionRestrictions));\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tPositionRestrictions,\r\n\tSizeRestrictions,\r\n\tTransform,\r\n\tCoordinates,\r\n\tSize,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { MoveEvent } from '../events';\r\nimport { approximatedSize } from './approximatedSize';\r\nimport { isUndefined } from '../utils';\r\nimport { move } from './move';\r\n\r\ninterface ApplyTransformParams {\r\n\tcoordinates: Coordinates;\r\n\ttransform: Transform | Transform[];\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\timageSize: Size;\r\n\tvisibleArea: VisibleArea;\r\n\taspectRatio?: AspectRatio;\r\n}\r\n\r\nexport function applyTransform(params: ApplyTransformParams) {\r\n\tconst {\r\n\t\tcoordinates: initialCoordinates,\r\n\t\ttransform,\r\n\t\timageSize,\r\n\t\tsizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t\taspectRatio,\r\n\t\tvisibleArea,\r\n\t} = params;\r\n\r\n\tconst moveAlgorithm = (prevCoordinates, newCoordinates) => {\r\n\t\treturn move({\r\n\t\t\tcoordinates: prevCoordinates,\r\n\t\t\tpositionRestrictions,\r\n\t\t\tevent: new MoveEvent({\r\n\t\t\t\tleft: newCoordinates.left - prevCoordinates.left,\r\n\t\t\t\ttop: newCoordinates.top - prevCoordinates.top,\r\n\t\t\t}),\r\n\t\t});\r\n\t};\r\n\r\n\tconst resizeAlgorithm = (prevCoordinates, newCoordinates) => {\r\n\t\tlet coordinates = {\r\n\t\t\t...prevCoordinates,\r\n\t\t\t...approximatedSize({\r\n\t\t\t\twidth: newCoordinates.width,\r\n\t\t\t\theight: newCoordinates.height,\r\n\t\t\t\tsizeRestrictions,\r\n\t\t\t\taspectRatio,\r\n\t\t\t}),\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t};\r\n\r\n\t\treturn moveAlgorithm(coordinates, {\r\n\t\t\tleft: prevCoordinates.left,\r\n\t\t\ttop: prevCoordinates.top,\r\n\t\t});\r\n\t};\r\n\r\n\tlet coordinates = { ...initialCoordinates };\r\n\r\n\tconst transforms = Array.isArray(transform) ? transform : [transform];\r\n\r\n\ttransforms.forEach((transform) => {\r\n\t\tlet changes: Partial<Coordinates> = {};\r\n\t\tif (typeof transform === 'function') {\r\n\t\t\tchanges = transform({ coordinates, imageSize, visibleArea });\r\n\t\t} else {\r\n\t\t\tchanges = transform;\r\n\t\t}\r\n\r\n\t\tif (!isUndefined(changes.width) || !isUndefined(changes.height)) {\r\n\t\t\tcoordinates = resizeAlgorithm(coordinates, { ...coordinates, ...changes });\r\n\t\t}\r\n\t\tif (!isUndefined(changes.left) || !isUndefined(changes.top)) {\r\n\t\t\tcoordinates = moveAlgorithm(coordinates, { ...coordinates, ...changes });\r\n\t\t}\r\n\t});\r\n\r\n\treturn coordinates;\r\n}\r\n","import {\r\n\tadjustSize,\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tdiff,\r\n\tfit,\r\n\tfitToLimits,\r\n\tgetCenter,\r\n\tintersectionLimits,\r\n\tinverseMove,\r\n\tmaxScale,\r\n\tratio,\r\n\ttoLimits,\r\n} from '../service';\r\nimport {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tCoordinates,\r\n\tCropperEvent,\r\n\tGetAreaRestrictions,\r\n\tPositionRestrictions,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { isApproximatelyEqual } from '../utils';\r\nimport { approximatedSize } from './approximatedSize';\r\nimport { ALL_DIRECTIONS } from '../constants';\r\n\r\ninterface AutoZoomResult {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n}\r\n\r\ninterface AutoZoomParams {\r\n\tevent: CropperEvent;\r\n\tcoordinates: Coordinates;\r\n\tstencilReference: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tboundaries: Boundaries;\r\n\taspectRatio: AspectRatio;\r\n\tstencilSize: Size;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n}\r\n\r\nexport function fixedStencilAutoZoom(params: AutoZoomParams): AutoZoomResult {\r\n\tconst {\r\n\t\tevent,\r\n\t\tgetAreaRestrictions,\r\n\t\tboundaries,\r\n\t\tcoordinates: originalCoordinates,\r\n\t\tvisibleArea: originalVisibleArea,\r\n\t\taspectRatio,\r\n\t\tstencilSize,\r\n\t\tsizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t\tstencilReference,\r\n\t} = params;\r\n\r\n\tlet coordinates = { ...originalCoordinates };\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\r\n\t// Checks that coordinates has the same ratio that coordinates:\r\n\tlet stencil = { ...stencilSize };\r\n\r\n\tif (!isApproximatelyEqual(ratio(stencil), ratio(coordinates))) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`[Adjusting stencil] The aspect ratio of coordinates is not equal to the aspect ratio of stencil (${ratio(\r\n\t\t\t\t\tcoordinates,\r\n\t\t\t\t)} != ${ratio(stencil)})! Coordinates will be changed`,\r\n\t\t\t);\r\n\t\t}\r\n\t\tcoordinates = {\r\n\t\t\t...coordinates,\r\n\t\t\t...approximatedSize({\r\n\t\t\t\tsizeRestrictions,\r\n\t\t\t\twidth: coordinates.width,\r\n\t\t\t\theight: coordinates.height,\r\n\t\t\t\taspectRatio: {\r\n\t\t\t\t\tminimum: ratio(stencil),\r\n\t\t\t\t\tmaximum: ratio(stencil),\r\n\t\t\t\t},\r\n\t\t\t}),\r\n\t\t};\r\n\t}\r\n\r\n\t// First of all try to resize visible area as much as possible:\r\n\tvisibleArea = applyScale(visibleArea, (coordinates.width * boundaries.width) / (visibleArea.width * stencil.width));\r\n\r\n\t// Check that visible area doesn't break the area restrictions:\r\n\tconst scale = adjustSize(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' }));\r\n\tif (scale !== 1) {\r\n\t\tvisibleArea = applyScale(visibleArea, scale);\r\n\t\tcoordinates = applyScale(coordinates, scale);\r\n\t}\r\n\r\n\tvisibleArea = applyMove(visibleArea, diff(getCenter(coordinates), getCenter(visibleArea)));\r\n\r\n\t// Center stencil in visible area:\r\n\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\tcoordinates = fitToLimits(coordinates, intersectionLimits(toLimits(visibleArea), positionRestrictions));\r\n\r\n\treturn {\r\n\t\tcoordinates,\r\n\t\tvisibleArea,\r\n\t};\r\n}\r\n\r\nexport function hybridStencilAutoZoom(params: AutoZoomParams): AutoZoomResult {\r\n\tconst {\r\n\t\tevent,\r\n\t\tgetAreaRestrictions,\r\n\t\tboundaries,\r\n\t\tcoordinates: originalCoordinates,\r\n\t\tvisibleArea: originalVisibleArea,\r\n\t\taspectRatio,\r\n\t\tstencilSize,\r\n\t\tsizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t\tstencilReference,\r\n\t} = params;\r\n\r\n\tlet coordinates = { ...originalCoordinates };\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\r\n\tif (originalCoordinates && originalVisibleArea && event.type !== 'manipulateImage') {\r\n\t\t// Checks that coordinates has the same ratio that coordinates:\r\n\t\tlet stencil: Size = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0,\r\n\t\t};\r\n\r\n\t\tconst coefficient = visibleArea.width / boundaries.width;\r\n\r\n\t\tif (ratio(boundaries) > ratio(coordinates)) {\r\n\t\t\tstencil.height = boundaries.height * 0.8;\r\n\t\t\tstencil.width = stencil.height * ratio(coordinates);\r\n\t\t} else {\r\n\t\t\tstencil.width = boundaries.width * 0.8;\r\n\t\t\tstencil.height = stencil.width * ratio(coordinates);\r\n\t\t}\r\n\r\n\t\t// First of all try to resize visible area as much as possible:\r\n\t\tvisibleArea = applyScale(\r\n\t\t\tvisibleArea,\r\n\t\t\t(coordinates.width * boundaries.width) / (visibleArea.width * stencil.width),\r\n\t\t);\r\n\r\n\t\t// Check that visible area doesn't break the area restrictions:\r\n\t\tconst scale = adjustSize(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' }));\r\n\t\tvisibleArea = applyScale(visibleArea, scale);\r\n\r\n\t\tif (scale !== 1) {\r\n\t\t\tstencil.height /= scale;\r\n\t\t\tstencil.width /= scale;\r\n\t\t}\r\n\r\n\t\tvisibleArea = applyMove(visibleArea, diff(getCenter(coordinates), getCenter(visibleArea)));\r\n\r\n\t\t// Center stencil in visible area:\r\n\t\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\t\tcoordinates = fitToLimits(coordinates, intersectionLimits(toLimits(visibleArea), positionRestrictions));\r\n\t}\r\n\r\n\treturn {\r\n\t\tcoordinates,\r\n\t\tvisibleArea,\r\n\t};\r\n}\r\n\r\n// The main point of this feature is calculating the needed position of stencil and parameters of world transforms\r\n// Real coordinates don't changes here\r\ninterface SimplestAutoZoomParams {\r\n\tevent: CropperEvent;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n}\r\nexport function simplestAutoZoom(params: SimplestAutoZoomParams): AutoZoomResult {\r\n\tconst { event, coordinates: originalCoordinates, visibleArea: originalVisibleArea, getAreaRestrictions } = params;\r\n\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\tconst coordinates = { ...originalCoordinates };\r\n\r\n\tif (event.type === 'setCoordinates') {\r\n\t\tconst widthIntersections = Math.max(0, coordinates.width - visibleArea.width);\r\n\t\tconst heightIntersections = Math.max(0, coordinates.height - visibleArea.height);\r\n\r\n\t\tif (widthIntersections > heightIntersections) {\r\n\t\t\tvisibleArea = applyScale(\r\n\t\t\t\tvisibleArea,\r\n\t\t\t\tMath.min(\r\n\t\t\t\t\tcoordinates.width / visibleArea.width,\r\n\t\t\t\t\tmaxScale(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\r\n\t\t\t\t),\r\n\t\t\t);\r\n\t\t} else if (heightIntersections > widthIntersections) {\r\n\t\t\tvisibleArea = applyScale(\r\n\t\t\t\tvisibleArea,\r\n\t\t\t\tMath.min(\r\n\t\t\t\t\tcoordinates.height / visibleArea.height,\r\n\t\t\t\t\tmaxScale(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\r\n\t\t\t\t),\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tvisibleArea = applyMove(visibleArea, inverseMove(fit(coordinates, toLimits(visibleArea))));\r\n\r\n\t\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\t}\r\n\treturn {\r\n\t\tvisibleArea,\r\n\t\tcoordinates,\r\n\t};\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tFalsy,\r\n\tImageSize,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tStencilSize,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { approximatedSize } from './approximatedSize';\r\nimport { ratio } from '../service';\r\nimport { isNumber } from '../utils';\r\n\r\ninterface DefaultSizeBasicParams {\r\n\taspectRatio: AspectRatio;\r\n\tboundaries: Boundaries;\r\n\tsizeRestrictions: SizeRestrictions;\r\n}\r\n\r\ninterface ImageDefaultSizeParams extends DefaultSizeBasicParams {\r\n\timageSize: ImageSize;\r\n\tvisibleArea?: VisibleArea | Falsy;\r\n}\r\n\r\ninterface VisibleAreaDefaultSizeParams extends DefaultSizeBasicParams {\r\n\timageSize?: ImageSize | Falsy;\r\n\tvisibleArea: VisibleArea;\r\n}\r\n\r\nexport type DefaultSizeParams = VisibleAreaDefaultSizeParams | ImageDefaultSizeParams;\r\n\r\nexport function defaultSize(params: DefaultSizeParams): Size {\r\n\tconst { imageSize, visibleArea, aspectRatio, sizeRestrictions } = params;\r\n\r\n\tconst area = (visibleArea || imageSize) as Size;\r\n\r\n\tconst optimalRatio = Math.min(aspectRatio.maximum || Infinity, Math.max(aspectRatio.minimum || 0, ratio(area)));\r\n\r\n\tconst size =\r\n\t\tarea.width < area.height\r\n\t\t\t? {\r\n\t\t\t\t\twidth: area.width * 0.8,\r\n\t\t\t\t\theight: (area.width * 0.8) / optimalRatio,\r\n\t\t\t  }\r\n\t\t\t: {\r\n\t\t\t\t\theight: area.height * 0.8,\r\n\t\t\t\t\twidth: area.height * 0.8 * optimalRatio,\r\n\t\t\t  };\r\n\r\n\treturn approximatedSize({\r\n\t\t...size,\r\n\t\taspectRatio,\r\n\t\tsizeRestrictions: sizeRestrictions,\r\n\t});\r\n}\r\n\r\nexport type FixedDefaultSizeParams = DefaultSizeParams & { stencilSize: Size };\r\n\r\nexport function fixedDefaultSize(params: FixedDefaultSizeParams): Size {\r\n\tconst { imageSize, visibleArea, boundaries, aspectRatio, sizeRestrictions, stencilSize } = params;\r\n\r\n\tconst area = (visibleArea || imageSize) as Size;\r\n\r\n\tlet height, width;\r\n\tif (ratio(area) > ratio(boundaries)) {\r\n\t\theight = (stencilSize.height * area.height) / boundaries.height;\r\n\t\twidth = height * ratio(stencilSize);\r\n\t} else {\r\n\t\twidth = (stencilSize.width * area.width) / boundaries.width;\r\n\t\theight = width / ratio(stencilSize);\r\n\t}\r\n\r\n\treturn approximatedSize({\r\n\t\twidth,\r\n\t\theight,\r\n\t\taspectRatio,\r\n\t\tsizeRestrictions: sizeRestrictions,\r\n\t});\r\n}\r\n","import { Coordinates, Limits } from '../typings';\r\nimport { joinLimits } from '../service';\r\nimport { toLimits } from '../service';\r\n\r\nexport function limitBy(limits: Limits, object: Coordinates): Limits {\r\n\treturn joinLimits(limits, toLimits(object));\r\n}\r\n","import { ManipulateImageEvent } from '../events';\r\nimport { GetAreaRestrictions, Coordinates, PositionRestrictions, SizeRestrictions, VisibleArea } from '../typings';\r\nimport {\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tfit,\r\n\tfitToLimits,\r\n\tgetCenter,\r\n\tintersectionLimits,\r\n\tinverseMove,\r\n\tmaxScale,\r\n\ttoLimits,\r\n} from '../service';\r\n\r\ninterface ManipulateImageParams {\r\n\tevent: ManipulateImageEvent;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n\tadjustStencil: boolean;\r\n}\r\ninterface ManipulateImageResult {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n}\r\nexport function manipulateImage(params: ManipulateImageParams): ManipulateImageResult {\r\n\tconst {\r\n\t\tevent,\r\n\t\tcoordinates: originalCoordinates,\r\n\t\tvisibleArea: originalVisibleArea,\r\n\t\tsizeRestrictions,\r\n\t\tgetAreaRestrictions,\r\n\t\tpositionRestrictions,\r\n\t\tadjustStencil,\r\n\t} = params;\r\n\r\n\tconst { scale, move } = event;\r\n\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\tlet coordinates = { ...originalCoordinates };\r\n\r\n\tlet areaScale = 1;\r\n\tlet stencilScale = 1;\r\n\tconst allowedScale = scale.factor && Math.abs(scale.factor - 1) > 1e-3;\r\n\r\n\tvisibleArea = applyMove(visibleArea, {\r\n\t\tleft: move.left || 0,\r\n\t\ttop: move.top || 0,\r\n\t});\r\n\r\n\tconst scaleRestrictions = {\r\n\t\tstencil: {\r\n\t\t\tminimum: Math.max(\r\n\t\t\t\tsizeRestrictions.minWidth ? sizeRestrictions.minWidth / coordinates.width : 0,\r\n\t\t\t\tsizeRestrictions.minHeight ? sizeRestrictions.minHeight / coordinates.height : 0,\r\n\t\t\t),\r\n\t\t\tmaximum: Math.min(\r\n\t\t\t\tsizeRestrictions.maxWidth ? sizeRestrictions.maxWidth / coordinates.width : Infinity,\r\n\t\t\t\tsizeRestrictions.maxHeight ? sizeRestrictions.maxHeight / coordinates.height : Infinity,\r\n\t\t\t\tmaxScale(coordinates, positionRestrictions),\r\n\t\t\t),\r\n\t\t},\r\n\t\tarea: {\r\n\t\t\tmaximum: maxScale(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\r\n\t\t},\r\n\t};\r\n\r\n\t// If there is scaling then begin scale\r\n\tif (scale.factor && allowedScale) {\r\n\t\t// Determine scale factor\r\n\t\tif (scale.factor < 1) {\r\n\t\t\tstencilScale = Math.max(scale.factor, scaleRestrictions.stencil.minimum);\r\n\t\t\tif (stencilScale > 1) {\r\n\t\t\t\tstencilScale = 1;\r\n\t\t\t}\r\n\t\t} else if (scale.factor > 1) {\r\n\t\t\tstencilScale = Math.min(\r\n\t\t\t\tscale.factor,\r\n\t\t\t\tMath.min(scaleRestrictions.area.maximum, scaleRestrictions.stencil.maximum),\r\n\t\t\t);\r\n\t\t\tif (stencilScale < 1) {\r\n\t\t\t\tstencilScale = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (stencilScale) {\r\n\t\t// Resize stencil with area as much is possible\r\n\t\tvisibleArea = applyScale(visibleArea, stencilScale, scale.center);\r\n\t}\r\n\r\n\tconst relativeCoordinates = {\r\n\t\tleft: originalCoordinates.left - originalVisibleArea.left,\r\n\t\tright:\r\n\t\t\toriginalVisibleArea.width +\r\n\t\t\toriginalVisibleArea.left -\r\n\t\t\t(originalCoordinates.width + originalCoordinates.left),\r\n\t\ttop: originalCoordinates.top - originalVisibleArea.top,\r\n\t\tbottom:\r\n\t\t\toriginalVisibleArea.height +\r\n\t\t\toriginalVisibleArea.top -\r\n\t\t\t(originalCoordinates.height + originalCoordinates.top),\r\n\t};\r\n\r\n\t// Move the area to fit to coordinates limits:\r\n\tvisibleArea = applyMove(\r\n\t\tvisibleArea,\r\n\t\tfit(visibleArea, {\r\n\t\t\tleft:\r\n\t\t\t\tpositionRestrictions.left !== undefined\r\n\t\t\t\t\t? positionRestrictions.left - relativeCoordinates.left * stencilScale\r\n\t\t\t\t\t: undefined,\r\n\t\t\ttop:\r\n\t\t\t\tpositionRestrictions.top !== undefined\r\n\t\t\t\t\t? positionRestrictions.top - relativeCoordinates.top * stencilScale\r\n\t\t\t\t\t: undefined,\r\n\t\t\tbottom:\r\n\t\t\t\tpositionRestrictions.bottom !== undefined\r\n\t\t\t\t\t? positionRestrictions.bottom + relativeCoordinates.bottom * stencilScale\r\n\t\t\t\t\t: undefined,\r\n\t\t\tright:\r\n\t\t\t\tpositionRestrictions.right !== undefined\r\n\t\t\t\t\t? positionRestrictions.right + relativeCoordinates.right * stencilScale\r\n\t\t\t\t\t: undefined,\r\n\t\t}),\r\n\t);\r\n\r\n\t// But the more important to fit are to the area restrictions, so we should fit it to that restrictions:\r\n\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\r\n\t// Set the same coordinates of stencil inside visible area\r\n\tcoordinates.width = coordinates.width * stencilScale;\r\n\tcoordinates.height = coordinates.height * stencilScale;\r\n\tcoordinates.left = visibleArea.left + relativeCoordinates.left * stencilScale;\r\n\tcoordinates.top = visibleArea.top + relativeCoordinates.top * stencilScale;\r\n\r\n\t// Move the coordinates to prevent the intersection with visible area and position restrictions\r\n\tcoordinates = fitToLimits(coordinates, intersectionLimits(toLimits(visibleArea), positionRestrictions));\r\n\r\n\t// Resize only area if stencil can't be resized and stencil resize is disabled\r\n\tif (scale.factor && allowedScale && adjustStencil) {\r\n\t\tif (scale.factor > 1) {\r\n\t\t\tareaScale = Math.min(scaleRestrictions.area.maximum, scale.factor) / stencilScale;\r\n\t\t} else if (scale.factor < 1) {\r\n\t\t\tareaScale = Math.max(\r\n\t\t\t\tcoordinates.height / visibleArea.height,\r\n\t\t\t\tcoordinates.width / visibleArea.width,\r\n\t\t\t\tscale.factor / stencilScale,\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (areaScale !== 1) {\r\n\t\t\tvisibleArea = applyScale(visibleArea, areaScale, scale.factor > 1 ? scale.center : getCenter(coordinates));\r\n\r\n\t\t\t// Move to prevent the breaking of the area restrictions:\r\n\t\t\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\r\n\t\t\t// Move to prevent the intersection with coordinates:\r\n\t\t\tvisibleArea = applyMove(visibleArea, inverseMove(fit(coordinates, toLimits(visibleArea))));\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcoordinates,\r\n\t\tvisibleArea,\r\n\t};\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tCoordinates,\r\n\tCropperEvent,\r\n\tGetAreaRestrictions,\r\n\tImageSize,\r\n\tPositionRestrictions,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { isApproximatelyEqual, sign } from '../utils';\r\nimport {\r\n\tadjustSize,\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tdiff,\r\n\tfitSize,\r\n\tfitToLimits,\r\n\tgetCenter,\r\n\tintersectionLimits,\r\n\tratio,\r\n\trotatePoint,\r\n\trotateSize,\r\n\ttoLimits,\r\n} from '../service';\r\nimport { approximatedSize } from './approximatedSize';\r\n\r\ninterface RotateImageParams {\r\n\taspectRatio: AspectRatio;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n\timageSize: ImageSize;\r\n\tpreviousImageSize: ImageSize;\r\n\tangle: number;\r\n}\r\n\r\ninterface RotateImageResult {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n}\r\n\r\nexport function rotateImage(params: RotateImageParams): RotateImageResult {\r\n\tconst {\r\n\t\taspectRatio,\r\n\t\tgetAreaRestrictions,\r\n\t\tcoordinates: originalCoordinates,\r\n\t\tvisibleArea: originalVisibleArea,\r\n\t\tsizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t\timageSize,\r\n\t\tpreviousImageSize,\r\n\t\tangle,\r\n\t} = params;\r\n\r\n\tlet coordinates = { ...originalCoordinates };\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\r\n\tconst imageCenter = rotatePoint(\r\n\t\tgetCenter({\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t\t...previousImageSize,\r\n\t\t}),\r\n\t\tangle,\r\n\t);\r\n\r\n\tcoordinates = {\r\n\t\t...approximatedSize({\r\n\t\t\tsizeRestrictions,\r\n\t\t\taspectRatio,\r\n\t\t\twidth: coordinates.width,\r\n\t\t\theight: coordinates.height,\r\n\t\t}),\r\n\t\t...rotatePoint(getCenter(coordinates), angle),\r\n\t};\r\n\r\n\tcoordinates.left -= imageCenter.left - imageSize.width / 2 + coordinates.width / 2;\r\n\tcoordinates.top -= imageCenter.top - imageSize.height / 2 + coordinates.height / 2;\r\n\r\n\t// Check that visible area doesn't break the area restrictions:\r\n\tvisibleArea = applyScale(\r\n\t\tvisibleArea,\r\n\t\tadjustSize(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\r\n\t);\r\n\r\n\tcoordinates = fitToLimits(coordinates, positionRestrictions);\r\n\r\n\tvisibleArea = applyMove(visibleArea, diff(getCenter(coordinates), getCenter(originalCoordinates)));\r\n\r\n\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\r\n\treturn {\r\n\t\tcoordinates,\r\n\t\tvisibleArea,\r\n\t};\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tCoordinates,\r\n\tCropperEvent,\r\n\tGetAreaRestrictions,\r\n\tImageSize,\r\n\tPositionRestrictions,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { isApproximatelyEqual, sign } from '../utils';\r\nimport {\r\n\tadjustSize,\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tdiff,\r\n\tfitSize,\r\n\tfitToLimits,\r\n\tgetCenter,\r\n\tintersectionLimits,\r\n\tratio,\r\n\trotatePoint,\r\n\trotateSize,\r\n\ttoLimits,\r\n} from '../service';\r\nimport { approximatedSize } from './approximatedSize';\r\n\r\ninterface Reflect {\r\n\thorizontal: boolean;\r\n\tvertical: boolean;\r\n}\r\n\r\ninterface FlipImageParams {\r\n\taspectRatio: AspectRatio;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n\timageSize: ImageSize;\r\n\tpreviousFlip: Reflect;\r\n\tflip: Reflect;\r\n\trotate: number;\r\n}\r\n\r\ninterface FlipImageResult {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n}\r\n\r\nexport function flipImage(params: FlipImageParams): FlipImageResult {\r\n\tconst {\r\n\t\tflip,\r\n\t\tpreviousFlip,\r\n\t\trotate,\r\n\t\taspectRatio,\r\n\t\tgetAreaRestrictions,\r\n\t\tcoordinates: originalCoordinates,\r\n\t\tvisibleArea: originalVisibleArea,\r\n\t\timageSize,\r\n\t} = params;\r\n\r\n\tlet coordinates = { ...originalCoordinates };\r\n\tlet visibleArea = { ...originalVisibleArea };\r\n\r\n\tconst changed = {\r\n\t\thorizontal: previousFlip.horizontal !== flip.horizontal,\r\n\t\tvertical: previousFlip.vertical !== flip.vertical,\r\n\t};\r\n\r\n\tif (changed.horizontal || changed.vertical) {\r\n\t\tconst imageCenter = rotatePoint(\r\n\t\t\t{\r\n\t\t\t\tleft: imageSize.width / 2,\r\n\t\t\t\ttop: imageSize.height / 2,\r\n\t\t\t},\r\n\t\t\t-rotate,\r\n\t\t);\r\n\r\n\t\tlet oldCenter = rotatePoint(getCenter(coordinates), -rotate);\r\n\t\tlet newCenter = rotatePoint(\r\n\t\t\t{\r\n\t\t\t\tleft: changed.horizontal ? imageCenter.left - (oldCenter.left - imageCenter.left) : oldCenter.left,\r\n\t\t\t\ttop: changed.vertical ? imageCenter.top - (oldCenter.top - imageCenter.top) : oldCenter.top,\r\n\t\t\t},\r\n\t\t\trotate,\r\n\t\t);\r\n\t\tcoordinates = applyMove(coordinates, diff(newCenter, getCenter(coordinates)));\r\n\r\n\t\toldCenter = rotatePoint(getCenter(visibleArea), -rotate);\r\n\t\tnewCenter = rotatePoint(\r\n\t\t\t{\r\n\t\t\t\tleft: changed.horizontal ? imageCenter.left - (oldCenter.left - imageCenter.left) : oldCenter.left,\r\n\t\t\t\ttop: changed.vertical ? imageCenter.top - (oldCenter.top - imageCenter.top) : oldCenter.top,\r\n\t\t\t},\r\n\t\t\trotate,\r\n\t\t);\r\n\t\tvisibleArea = applyMove(visibleArea, diff(newCenter, getCenter(visibleArea)));\r\n\r\n\t\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\t}\r\n\r\n\treturn {\r\n\t\tcoordinates,\r\n\t\tvisibleArea,\r\n\t};\r\n}\r\n","import { MoveEvent, ResizeEvent } from '../events';\r\nimport { AspectRatio, Coordinates, Limits, PositionRestrictions, ResizeDirections, SizeRestrictions } from '../typings';\r\nimport { ALL_DIRECTIONS, HORIZONTAL_DIRECTIONS, VERTICAL_DIRECTIONS } from '../constants';\r\nimport { applyDirections, getBrokenRatio, getIntersections, ratio } from '../service';\r\nimport { move } from './move';\r\n\r\ninterface FitConditionsParams {\r\n\tdirections: ResizeDirections;\r\n\tcoordinates: Coordinates;\r\n\tpositionRestrictions: Limits;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpreserveRatio?: boolean;\r\n\tcompensate?: boolean;\r\n}\r\n\r\nexport function fitConditions({\r\n\tdirections,\r\n\tcoordinates,\r\n\tpositionRestrictions = {},\r\n\tsizeRestrictions,\r\n\tpreserveRatio,\r\n\tcompensate,\r\n}: FitConditionsParams): ResizeDirections {\r\n\tconst fittedDirections = { ...directions };\r\n\r\n\tlet currentWidth = applyDirections(coordinates, fittedDirections).width;\r\n\tlet currentHeight = applyDirections(coordinates, fittedDirections).height;\r\n\r\n\t// Prevent strange resizes when the width or height of stencil becomes smaller than 0\r\n\tif (currentWidth < 0) {\r\n\t\tif (fittedDirections.left < 0 && fittedDirections.right < 0) {\r\n\t\t\tfittedDirections.left =\r\n\t\t\t\t-(coordinates.width - sizeRestrictions.minWidth) / (fittedDirections.left / fittedDirections.right);\r\n\t\t\tfittedDirections.right =\r\n\t\t\t\t-(coordinates.width - sizeRestrictions.minWidth) / (fittedDirections.right / fittedDirections.left);\r\n\t\t} else if (fittedDirections.left < 0) {\r\n\t\t\tfittedDirections.left = -(coordinates.width - sizeRestrictions.minWidth);\r\n\t\t} else if (fittedDirections.right < 0) {\r\n\t\t\tfittedDirections.right = -(coordinates.width - sizeRestrictions.minWidth);\r\n\t\t}\r\n\t}\r\n\tif (currentHeight < 0) {\r\n\t\tif (fittedDirections.top < 0 && fittedDirections.bottom < 0) {\r\n\t\t\tfittedDirections.top =\r\n\t\t\t\t-(coordinates.height - sizeRestrictions.minHeight) / (fittedDirections.top / fittedDirections.bottom);\r\n\t\t\tfittedDirections.bottom =\r\n\t\t\t\t-(coordinates.height - sizeRestrictions.minHeight) / (fittedDirections.bottom / fittedDirections.top);\r\n\t\t} else if (fittedDirections.top < 0) {\r\n\t\t\tfittedDirections.top = -(coordinates.height - sizeRestrictions.minHeight);\r\n\t\t} else if (fittedDirections.bottom < 0) {\r\n\t\t\tfittedDirections.bottom = -(coordinates.height - sizeRestrictions.minHeight);\r\n\t\t}\r\n\t}\r\n\r\n\t// Prevent breaking limits\r\n\tlet breaks = getIntersections(applyDirections(coordinates, fittedDirections), positionRestrictions);\r\n\r\n\tif (compensate) {\r\n\t\tif (breaks.left && breaks.left > 0 && breaks.right === 0) {\r\n\t\t\tfittedDirections.right += breaks.left;\r\n\t\t\tfittedDirections.left -= breaks.left;\r\n\t\t} else if (breaks.right && breaks.right > 0 && breaks.left === 0) {\r\n\t\t\tfittedDirections.left += breaks.right;\r\n\t\t\tfittedDirections.right -= breaks.right;\r\n\t\t}\r\n\r\n\t\tif (breaks.top && breaks.top > 0 && breaks.bottom === 0) {\r\n\t\t\tfittedDirections.bottom += breaks.top;\r\n\t\t\tfittedDirections.top -= breaks.top;\r\n\t\t} else if (breaks.bottom && breaks.bottom > 0 && breaks.top === 0) {\r\n\t\t\tfittedDirections.top += breaks.bottom;\r\n\t\t\tfittedDirections.bottom -= breaks.bottom;\r\n\t\t}\r\n\r\n\t\tbreaks = getIntersections(applyDirections(coordinates, fittedDirections), positionRestrictions);\r\n\t}\r\n\r\n\tconst maxResize = {\r\n\t\twidth: Infinity,\r\n\t\theight: Infinity,\r\n\t\tleft: Infinity,\r\n\t\tright: Infinity,\r\n\t\ttop: Infinity,\r\n\t\tbottom: Infinity,\r\n\t};\r\n\r\n\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\tconst intersection = breaks[direction];\r\n\t\tif (intersection && fittedDirections[direction]) {\r\n\t\t\tmaxResize[direction] = Math.max(0, 1 - intersection / fittedDirections[direction]);\r\n\t\t}\r\n\t});\r\n\r\n\tif (preserveRatio) {\r\n\t\tconst multiplier = Math.min(...ALL_DIRECTIONS.map((direction) => maxResize[direction]));\r\n\t\tif (multiplier !== Infinity) {\r\n\t\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\t\tfittedDirections[direction] *= multiplier;\r\n\t\t\t});\r\n\t\t}\r\n\t} else {\r\n\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\tif (maxResize[direction] !== Infinity) {\r\n\t\t\t\tfittedDirections[direction] *= maxResize[direction];\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tcurrentWidth = applyDirections(coordinates, fittedDirections).width;\r\n\tcurrentHeight = applyDirections(coordinates, fittedDirections).height;\r\n\r\n\tif (fittedDirections.right + fittedDirections.left) {\r\n\t\tif (currentWidth > sizeRestrictions.maxWidth) {\r\n\t\t\tmaxResize.width =\r\n\t\t\t\t(sizeRestrictions.maxWidth - coordinates.width) / (fittedDirections.right + fittedDirections.left);\r\n\t\t} else if (currentWidth < sizeRestrictions.minWidth) {\r\n\t\t\tmaxResize.width =\r\n\t\t\t\t(sizeRestrictions.minWidth - coordinates.width) / (fittedDirections.right + fittedDirections.left);\r\n\t\t}\r\n\t}\r\n\r\n\tif (fittedDirections.bottom + fittedDirections.top) {\r\n\t\tif (currentHeight > sizeRestrictions.maxHeight) {\r\n\t\t\tmaxResize.height =\r\n\t\t\t\t(sizeRestrictions.maxHeight - coordinates.height) / (fittedDirections.bottom + fittedDirections.top);\r\n\t\t} else if (currentHeight < sizeRestrictions.minHeight) {\r\n\t\t\tmaxResize.height =\r\n\t\t\t\t(sizeRestrictions.minHeight - coordinates.height) / (fittedDirections.bottom + fittedDirections.top);\r\n\t\t}\r\n\t}\r\n\r\n\tif (preserveRatio) {\r\n\t\tconst multiplier = Math.min(maxResize.width, maxResize.height);\r\n\t\tif (multiplier !== Infinity) {\r\n\t\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\t\tfittedDirections[direction] *= multiplier;\r\n\t\t\t});\r\n\t\t}\r\n\t} else {\r\n\t\tif (maxResize.width !== Infinity) {\r\n\t\t\tHORIZONTAL_DIRECTIONS.forEach((direction) => {\r\n\t\t\t\tfittedDirections[direction] *= maxResize.width;\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (maxResize.height !== Infinity) {\r\n\t\t\tVERTICAL_DIRECTIONS.forEach((direction) => {\r\n\t\t\t\tfittedDirections[direction] *= maxResize.height;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\treturn fittedDirections;\r\n}\r\n\r\nexport interface ResizeParams {\r\n\tevent: ResizeEvent;\r\n\tcoordinates: Coordinates;\r\n\taspectRatio: AspectRatio;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n}\r\n\r\nfunction distributeOverlap(overlap: number, first: number, second: number) {\r\n\tif (first == 0 && second == 0) {\r\n\t\treturn overlap / 2;\r\n\t} else if (first == 0) {\r\n\t\treturn 0;\r\n\t} else if (second == 0) {\r\n\t\treturn overlap;\r\n\t} else {\r\n\t\treturn overlap * Math.abs(first / (first + second));\r\n\t}\r\n}\r\n\r\nexport function resize(params: ResizeParams): Coordinates {\r\n\tconst { event, coordinates, aspectRatio, positionRestrictions, sizeRestrictions } = params;\r\n\tconst actualCoordinates = {\r\n\t\t...coordinates,\r\n\t\tright: coordinates.left + coordinates.width,\r\n\t\tbottom: coordinates.top + coordinates.height,\r\n\t};\r\n\r\n\tconst eventParams = event.params || {};\r\n\r\n\tlet directions = {\r\n\t\t...event.directions,\r\n\t};\r\n\r\n\tconst allowedDirections = eventParams.allowedDirections || {\r\n\t\tleft: true,\r\n\t\tright: true,\r\n\t\tbottom: true,\r\n\t\ttop: true,\r\n\t};\r\n\r\n\tif (sizeRestrictions.widthFrozen) {\r\n\t\tdirections.left = 0;\r\n\t\tdirections.right = 0;\r\n\t}\r\n\r\n\tif (sizeRestrictions.heightFrozen) {\r\n\t\tdirections.top = 0;\r\n\t\tdirections.bottom = 0;\r\n\t}\r\n\r\n\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\tif (!allowedDirections[direction]) {\r\n\t\t\tdirections[direction] = 0;\r\n\t\t}\r\n\t});\r\n\r\n\t// 1. First step: determine the safe and desired area\r\n\tdirections = fitConditions({\r\n\t\tcoordinates: actualCoordinates,\r\n\t\tdirections,\r\n\t\tsizeRestrictions: sizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t});\r\n\r\n\t// 2. Second step: fix desired box to correspondent to aspect ratio\r\n\tlet currentWidth = applyDirections(actualCoordinates, directions).width;\r\n\tlet currentHeight = applyDirections(actualCoordinates, directions).height;\r\n\r\n\t// Checks ratio:\r\n\tlet ratioBroken = eventParams.preserveRatio\r\n\t\t? ratio(actualCoordinates)\r\n\t\t: getBrokenRatio(currentWidth / currentHeight, aspectRatio);\r\n\r\n\tif (ratioBroken) {\r\n\t\tlet { respectDirection } = eventParams;\r\n\t\tif (!respectDirection) {\r\n\t\t\tif (actualCoordinates.width >= actualCoordinates.height || ratioBroken === 1) {\r\n\t\t\t\trespectDirection = 'width';\r\n\t\t\t} else {\r\n\t\t\t\trespectDirection = 'height';\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (respectDirection === 'width') {\r\n\t\t\tconst overlapHeight = currentWidth / ratioBroken - actualCoordinates.height;\r\n\t\t\tif (allowedDirections.top && allowedDirections.bottom) {\r\n\t\t\t\tconst { top, bottom } = directions;\r\n\t\t\t\tdirections.bottom = distributeOverlap(overlapHeight, bottom, top);\r\n\t\t\t\tdirections.top = distributeOverlap(overlapHeight, top, bottom);\r\n\t\t\t} else if (allowedDirections.bottom) {\r\n\t\t\t\tdirections.bottom = overlapHeight;\r\n\t\t\t} else if (allowedDirections.top) {\r\n\t\t\t\tdirections.top = overlapHeight;\r\n\t\t\t} else if (allowedDirections.right) {\r\n\t\t\t\tdirections.right = 0;\r\n\t\t\t} else if (allowedDirections.left) {\r\n\t\t\t\tdirections.left = 0;\r\n\t\t\t}\r\n\t\t} else if (respectDirection === 'height') {\r\n\t\t\tconst overlapWidth = actualCoordinates.width - currentHeight * ratioBroken;\r\n\t\t\tif (allowedDirections.left && allowedDirections.right) {\r\n\t\t\t\tconst { left, right } = directions;\r\n\t\t\t\tdirections.left = -distributeOverlap(overlapWidth, left, right);\r\n\t\t\t\tdirections.right = -distributeOverlap(overlapWidth, right, left);\r\n\t\t\t} else if (allowedDirections.left) {\r\n\t\t\t\tdirections.left = -overlapWidth;\r\n\t\t\t} else if (allowedDirections.right) {\r\n\t\t\t\tdirections.right = -overlapWidth;\r\n\t\t\t} else if (allowedDirections.top) {\r\n\t\t\t\tdirections.top = 0;\r\n\t\t\t} else if (allowedDirections.bottom) {\r\n\t\t\t\tdirections.bottom = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 3. Third step: check if desired box with correct aspect ratios break some limits and fit to this conditions\r\n\t\tdirections = fitConditions({\r\n\t\t\tdirections,\r\n\t\t\tcoordinates: actualCoordinates,\r\n\t\t\tsizeRestrictions: sizeRestrictions,\r\n\t\t\tpositionRestrictions,\r\n\t\t\tpreserveRatio: true,\r\n\t\t\tcompensate: eventParams.compensate,\r\n\t\t});\r\n\t}\r\n\r\n\t// 4. Check if ratio broken (temporary):\r\n\tcurrentWidth = applyDirections(actualCoordinates, directions).width;\r\n\tcurrentHeight = applyDirections(actualCoordinates, directions).height;\r\n\tratioBroken = eventParams.preserveRatio\r\n\t\t? ratio(actualCoordinates)\r\n\t\t: getBrokenRatio(currentWidth / currentHeight, aspectRatio);\r\n\tif (ratioBroken && Math.abs(ratioBroken - currentWidth / currentHeight) > 1e-3) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`Something went wrong and ratio was broken: ${currentWidth / currentHeight} instead of ${ratioBroken}`,\r\n\t\t\t);\r\n\t\t}\r\n\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\tif (!allowedDirections[direction]) {\r\n\t\t\t\tdirections[direction] = 0;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\treturn move({\r\n\t\tevent: new MoveEvent({\r\n\t\t\tleft: -directions.left,\r\n\t\t\ttop: -directions.top,\r\n\t\t}),\r\n\t\tcoordinates: {\r\n\t\t\twidth: coordinates.width + directions.right + directions.left,\r\n\t\t\theight: coordinates.height + directions.top + directions.bottom,\r\n\t\t\tleft: coordinates.left,\r\n\t\t\ttop: coordinates.top,\r\n\t\t},\r\n\t\tpositionRestrictions,\r\n\t});\r\n}\r\n","<script>\r\nimport classnames from 'classnames';\r\nimport bem from 'easy-bem';\r\nimport { HandlerWrapper } from '../service';\r\n\r\nconst block = bem('vue-simple-handler');\r\nconst wrapper = bem('vue-simple-handler-wrapper');\r\n\r\nexport default {\r\n\tname: 'SimpleHandler',\r\n\tcomponents: {\r\n\t\tHandlerWrapper,\r\n\t},\r\n\tprops: {\r\n\t\tdefaultClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\thoverClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\twrapperClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\thorizontalPosition: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\tverticalPosition: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\tdisabled: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t},\r\n\tdata() {\r\n\t\treturn {\r\n\t\t\thover: false,\r\n\t\t};\r\n\t},\r\n\tcomputed: {\r\n\t\tclasses() {\r\n\t\t\tconst options = {\r\n\t\t\t\t[this.horizontalPosition]: Boolean(this.horizontalPosition),\r\n\t\t\t\t[this.verticalPosition]: Boolean(this.verticalPosition),\r\n\t\t\t\t[`${this.horizontalPosition}-${this.verticalPosition}`]: Boolean(\r\n\t\t\t\t\tthis.verticalPosition && this.horizontalPosition,\r\n\t\t\t\t),\r\n\t\t\t\thover: this.hover,\r\n\t\t\t};\r\n\t\t\treturn {\r\n\t\t\t\tdefault: classnames(block(options), this.defaultClass, this.hover && this.hoverClass),\r\n\t\t\t\twrapper: classnames(wrapper(options), this.wrapperClass),\r\n\t\t\t};\r\n\t\t},\r\n\t},\r\n\tmethods: {\r\n\t\tonDrag(dragEvent) {\r\n\t\t\tthis.$emit('drag', dragEvent);\r\n\t\t},\r\n\t\tonEnter() {\r\n\t\t\tthis.hover = true;\r\n\t\t},\r\n\t\tonLeave() {\r\n\t\t\tthis.hover = false;\r\n\t\t},\r\n\t\tonDragEnd() {\r\n\t\t\tthis.$emit('drag-end');\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<HandlerWrapper\r\n\t\t:class=\"classes.wrapper\"\r\n\t\t:vertical-position=\"verticalPosition\"\r\n\t\t:horizontal-position=\"horizontalPosition\"\r\n\t\t:disabled=\"disabled\"\r\n\t\t@drag=\"onDrag\"\r\n\t\t@drag-end=\"onDragEnd\"\r\n\t\t@enter=\"onEnter\"\r\n\t\t@leave=\"onLeave\"\r\n\t>\r\n\t\t<div :class=\"classes.default\" />\r\n\t</HandlerWrapper>\r\n</template>\r\n\r\n<style lang=\"scss\">\r\n.vue-simple-handler {\r\n\tdisplay: block;\r\n\tbackground: white;\r\n\theight: 10px;\r\n\twidth: 10px;\r\n}\r\n</style>\r\n","import { ImageTransforms } from './typings';\r\nimport { getCenter, rotatePoint, rotateSize } from './service';\r\n\r\nexport const XHR_DONE = 4;\r\n\r\nexport function prepareSource(canvas, image, { rotate, flip }) {\r\n\tconst originalSize = {\r\n\t\twidth: image.naturalWidth,\r\n\t\theight: image.naturalHeight,\r\n\t};\r\n\r\n\tconst transformedSize = rotateSize(originalSize, rotate);\r\n\r\n\tconst ctx = canvas.getContext('2d');\r\n\tcanvas.height = transformedSize.height;\r\n\tcanvas.width = transformedSize.width;\r\n\r\n\tctx.save();\r\n\r\n\t// Rotation:\r\n\tconst originalCenter = {\r\n\t\tleft: originalSize.width / 2,\r\n\t\ttop: originalSize.height / 2,\r\n\t};\r\n\r\n\tlet canvasCenter = rotatePoint(\r\n\t\tgetCenter({\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t\t...originalSize,\r\n\t\t}),\r\n\t\trotate,\r\n\t);\r\n\r\n\tctx.translate(-(canvasCenter.left - transformedSize.width / 2), -(canvasCenter.top - transformedSize.height / 2));\r\n\tctx.rotate((rotate * Math.PI) / 180);\r\n\r\n\t// Reflection;\r\n\tctx.translate(flip.horizontal ? originalSize.width : 0, flip.vertical ? originalSize.height : 0);\r\n\tctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);\r\n\r\n\tctx.drawImage(image, 0, 0, originalSize.width, originalSize.height);\r\n\tctx.restore();\r\n\r\n\treturn canvas;\r\n}\r\n\r\nfunction base64ToArrayBuffer(base64) {\r\n\tbase64 = base64.replace(/^data:([^;]+);base64,/gim, '');\r\n\tconst binary = atob(base64);\r\n\tconst len = binary.length;\r\n\tconst buffer = new ArrayBuffer(len);\r\n\tconst view = new Uint8Array(buffer);\r\n\tfor (let i = 0; i < len; i++) {\r\n\t\tview[i] = binary.charCodeAt(i);\r\n\t}\r\n\treturn buffer;\r\n}\r\n\r\nfunction objectURLToBlob(url, callback) {\r\n\tconst http = new XMLHttpRequest();\r\n\thttp.open('GET', url, true);\r\n\thttp.responseType = 'blob';\r\n\thttp.onload = function () {\r\n\t\tif (this.status == 200 || this.status === 0) {\r\n\t\t\tcallback(this.response);\r\n\t\t}\r\n\t};\r\n\thttp.send();\r\n}\r\n\r\nexport function getImageTransforms(orientation: number) {\r\n\tconst result: ImageTransforms = {\r\n\t\tflip: {\r\n\t\t\thorizontal: false,\r\n\t\t\tvertical: false,\r\n\t\t},\r\n\t\trotate: 0,\r\n\t};\r\n\tif (orientation) {\r\n\t\tswitch (orientation) {\r\n\t\t\tcase 2:\r\n\t\t\t\tresult.flip.horizontal = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tresult.rotate = -180;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tresult.flip.vertical = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tresult.rotate = 90;\r\n\t\t\t\tresult.flip.vertical = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tresult.rotate = 90;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 7:\r\n\t\t\t\tresult.rotate = 90;\r\n\t\t\t\tresult.flip.horizontal = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 8:\r\n\t\t\t\tresult.rotate = -90;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\nfunction getImageData(img) {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tif (img) {\r\n\t\t\t\tif (/^data:/i.test(img)) {\r\n\t\t\t\t\t// Data URL\r\n\t\t\t\t\tresolve(base64ToArrayBuffer(img));\r\n\t\t\t\t} else if (/^blob:/i.test(img)) {\r\n\t\t\t\t\t// Blob\r\n\t\t\t\t\tconst fileReader = new FileReader();\r\n\t\t\t\t\tfileReader.onload = function (e) {\r\n\t\t\t\t\t\tresolve(e.target.result);\r\n\t\t\t\t\t};\r\n\t\t\t\t\tobjectURLToBlob(img, function (blob) {\r\n\t\t\t\t\t\tfileReader.readAsArrayBuffer(blob);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Simple URL\r\n\t\t\t\t\tlet http = new XMLHttpRequest();\r\n\t\t\t\t\thttp.onreadystatechange = function () {\r\n\t\t\t\t\t\tif (http.readyState !== XHR_DONE) return;\r\n\r\n\t\t\t\t\t\tif (http.status === 200 || http.status === 0) {\r\n\t\t\t\t\t\t\tresolve(http.response);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treject('Warning: could not load an image to parse its orientation');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\thttp = null;\r\n\t\t\t\t\t};\r\n\t\t\t\t\thttp.onprogress = function () {\r\n\t\t\t\t\t\t// Abort the request directly if it not a JPEG image for better performance\r\n\t\t\t\t\t\tif (http.getResponseHeader('content-type') !== 'image/jpeg') {\r\n\t\t\t\t\t\t\thttp.abort();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\thttp.withCredentials = false;\r\n\t\t\t\t\thttp.open('GET', img, true);\r\n\t\t\t\t\thttp.responseType = 'arraybuffer';\r\n\t\t\t\t\thttp.send(null);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treject('Error: the image is empty');\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treject(e);\r\n\t\t}\r\n\t});\r\n}\r\n\r\nexport function getStyleTransforms({ rotate, flip, scaleX, scaleY }) {\r\n\tlet transform = '';\r\n\ttransform += ` rotate(${rotate}deg) `;\r\n\ttransform += ` scaleX(${scaleX * (flip.horizontal ? -1 : 1)}) `;\r\n\ttransform += ` scaleY(${scaleY * (flip.vertical ? -1 : 1)}) `;\r\n\treturn transform;\r\n}\r\n\r\nfunction getStringFromCharCode(dataView, start, length) {\r\n\tlet str = '';\r\n\tlet i;\r\n\tfor (i = start, length += start; i < length; i++) {\r\n\t\tstr += String.fromCharCode(dataView.getUint8(i));\r\n\t}\r\n\treturn str;\r\n}\r\n\r\nfunction resetAndGetOrientation(arrayBuffer) {\r\n\ttry {\r\n\t\tconst dataView = new DataView(arrayBuffer);\r\n\t\tlet orientation;\r\n\t\tlet exifIDCode;\r\n\t\tlet tiffOffset;\r\n\t\tlet littleEndian;\r\n\t\tlet app1Start;\r\n\t\tlet ifdStart;\r\n\t\t// Only handle JPEG image (start by 0xFFD8)\r\n\t\tif (dataView.getUint8(0) === 0xff && dataView.getUint8(1) === 0xd8) {\r\n\t\t\tconst length = dataView.byteLength;\r\n\t\t\tlet offset = 2;\r\n\t\t\twhile (offset + 1 < length) {\r\n\t\t\t\tif (dataView.getUint8(offset) === 0xff && dataView.getUint8(offset + 1) === 0xe1) {\r\n\t\t\t\t\tapp1Start = offset;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\toffset++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (app1Start) {\r\n\t\t\texifIDCode = app1Start + 4;\r\n\t\t\ttiffOffset = app1Start + 10;\r\n\t\t\tif (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\r\n\t\t\t\tconst endianness = dataView.getUint16(tiffOffset);\r\n\r\n\t\t\t\tlittleEndian = endianness === 0x4949;\r\n\r\n\t\t\t\tif (littleEndian || endianness === 0x4d4d /* bigEndian */) {\r\n\t\t\t\t\tif (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002a) {\r\n\t\t\t\t\t\tconst firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\r\n\t\t\t\t\t\tif (firstIFDOffset >= 0x00000008) {\r\n\t\t\t\t\t\t\tifdStart = tiffOffset + firstIFDOffset;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ifdStart) {\r\n\t\t\tconst length = dataView.getUint16(ifdStart, littleEndian);\r\n\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tlet offset = ifdStart + i * 12 + 2;\r\n\t\t\t\tif (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {\r\n\t\t\t\t\t// 8 is the offset of the current tag's value\r\n\t\t\t\t\toffset += 8;\r\n\t\t\t\t\t// Get the original orientation value\r\n\t\t\t\t\torientation = dataView.getUint16(offset, littleEndian);\r\n\t\t\t\t\t// Override the orientation with its default value\r\n\t\t\t\t\tdataView.setUint16(offset, 1, littleEndian);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn orientation;\r\n\t} catch (error) {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\nexport function parseImage(src: string) {\r\n\treturn new Promise((resolve) => {\r\n\t\tgetImageData(src)\r\n\t\t\t.then((data) => {\r\n\t\t\t\tconst orientation = resetAndGetOrientation(data);\r\n\t\t\t\tresolve(\r\n\t\t\t\t\tdata\r\n\t\t\t\t\t\t? { source: src, arrayBuffer: data, orientation }\r\n\t\t\t\t\t\t: { source: src, arrayBuffer: null, orientation: null },\r\n\t\t\t\t);\r\n\t\t\t})\r\n\t\t\t.catch((error) => {\r\n\t\t\t\tconsole.warn(error);\r\n\t\t\t\tresolve({ source: src, arrayBuffer: null, orientation: null });\r\n\t\t\t});\r\n\t});\r\n}\r\n\r\nexport function arrayBufferToDataURL(arrayBuffer) {\r\n\tconst chunks = [];\r\n\r\n\t// Chunk Typed Array for better performance\r\n\tconst chunkSize = 8192;\r\n\tlet uint8 = new Uint8Array(arrayBuffer);\r\n\r\n\twhile (uint8.length > 0) {\r\n\t\tconst value = uint8.subarray(0, chunkSize);\r\n\t\tchunks.push(String.fromCharCode.apply(null, Array.from ? Array.from(value) : value.slice()));\r\n\t\tuint8 = uint8.subarray(chunkSize);\r\n\t}\r\n\r\n\treturn `data:image/jpeg;base64,${btoa(chunks.join(''))}`;\r\n}\r\n","<script>\r\nimport bem from 'easy-bem';\r\nimport classnames from 'classnames';\r\nimport { radians } from '../../core';\r\nimport { getStyleTransforms } from '../../core/image';\r\nimport { rotateSize } from '../../core/service';\r\n\r\nconst cn = bem('vue-preview-result');\r\n\r\nexport default {\r\n\tname: 'PreviewResult',\r\n\tprops: {\r\n\t\timage: {\r\n\t\t\ttype: Object,\r\n\t\t},\r\n\t\ttransitions: {\r\n\t\t\ttype: Object,\r\n\t\t},\r\n\t\tstencilCoordinates: {\r\n\t\t\ttype: Object,\r\n\t\t\tdefault() {\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth: 0,\r\n\t\t\t\t\theight: 0,\r\n\t\t\t\t\tleft: 0,\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t},\r\n\t\timageClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t},\r\n\tcomputed: {\r\n\t\tclasses() {\r\n\t\t\treturn {\r\n\t\t\t\troot: cn(),\r\n\t\t\t\twrapper: cn('wrapper'),\r\n\t\t\t\timageWrapper: cn('image-wrapper'),\r\n\t\t\t\timage: classnames(cn('image'), this.imageClass),\r\n\t\t\t};\r\n\t\t},\r\n\t\twrapperStyle() {\r\n\t\t\tconst result = {\r\n\t\t\t\twidth: `${this.stencilCoordinates.width}px`,\r\n\t\t\t\theight: `${this.stencilCoordinates.height}px`,\r\n\t\t\t\tleft: `calc(50% - ${this.stencilCoordinates.width / 2}px)`,\r\n\t\t\t\ttop: `calc(50% - ${this.stencilCoordinates.height / 2}px)`,\r\n\t\t\t};\r\n\t\t\tif (this.transitions && this.transitions.enabled) {\r\n\t\t\t\tresult.transition = `${this.transitions.time}ms ${this.transitions.timingFunction}`;\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\timageStyle() {\r\n\t\t\tconst imageTransforms = this.image.transforms;\r\n\r\n\t\t\tconst virtualSize = rotateSize(\r\n\t\t\t\t{\r\n\t\t\t\t\twidth: this.image.width,\r\n\t\t\t\t\theight: this.image.height,\r\n\t\t\t\t},\r\n\t\t\t\timageTransforms.rotate,\r\n\t\t\t);\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\twidth: `${this.image.width}px`,\r\n\t\t\t\theight: `${this.image.height}px`,\r\n\t\t\t\tleft: '0px',\r\n\t\t\t\ttop: '0px',\r\n\t\t\t};\r\n\r\n\t\t\tconst compensations = {\r\n\t\t\t\trotate: {\r\n\t\t\t\t\tleft: ((this.image.width - virtualSize.width) * imageTransforms.scaleX) / 2,\r\n\t\t\t\t\ttop: ((this.image.height - virtualSize.height) * imageTransforms.scaleY) / 2,\r\n\t\t\t\t},\r\n\t\t\t\tscale: {\r\n\t\t\t\t\tleft: ((1 - imageTransforms.scaleX) * this.image.width) / 2,\r\n\t\t\t\t\ttop: ((1 - imageTransforms.scaleY) * this.image.height) / 2,\r\n\t\t\t\t},\r\n\t\t\t};\r\n\r\n\t\t\tresult.transform =\r\n\t\t\t\t`translate(\r\n\t\t\t\t${\r\n\t\t\t\t\t-this.stencilCoordinates.left -\r\n\t\t\t\t\timageTransforms.translateX -\r\n\t\t\t\t\tcompensations.rotate.left -\r\n\t\t\t\t\tcompensations.scale.left\r\n\t\t\t\t}px,${\r\n\t\t\t\t\t-this.stencilCoordinates.top -\r\n\t\t\t\t\timageTransforms.translateY -\r\n\t\t\t\t\tcompensations.rotate.top -\r\n\t\t\t\t\tcompensations.scale.top\r\n\t\t\t\t}px) ` + getStyleTransforms(imageTransforms);\r\n\r\n\t\t\tif (this.transitions && this.transitions.enabled) {\r\n\t\t\t\tresult.transition = `${this.transitions.time}ms ${this.transitions.timingFunction}`;\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<div :class=\"classes.root\">\r\n\t\t<div ref=\"wrapper\" :class=\"classes.wrapper\" :style=\"wrapperStyle\">\r\n\t\t\t<img ref=\"image\" :src=\"image.src\" :class=\"classes.image\" :style=\"imageStyle\" />\r\n\t\t</div>\r\n\t</div>\r\n</template>\r\n\r\n<style lang=\"scss\">\r\n.vue-preview-result {\r\n\toverflow: hidden;\r\n\tbox-sizing: border-box;\r\n\tposition: absolute;\r\n\theight: 100%;\r\n\twidth: 100%;\r\n\t&__wrapper {\r\n\t\tposition: absolute;\r\n\t}\r\n\r\n\t&__image {\r\n\t\tpointer-events: none;\r\n\t\tposition: relative;\r\n\t\tuser-select: none;\r\n\t\ttransform-origin: center;\r\n\t\t// Workaround to prevent bugs at the websites with max-width\r\n\t\t// rule applied to img (Vuepress for example)\r\n\t\tmax-width: none !important;\r\n\t}\r\n}\r\n</style>\r\n","import { distance } from './utils';\r\n\r\nexport function calculateGeometricProperties(touches: Touch[], container: HTMLElement) {\r\n\tconst { left, top } = container.getBoundingClientRect();\r\n\r\n\tconst centerMass = { left: 0, top: 0 };\r\n\tlet spread = 0;\r\n\r\n\ttouches.forEach((touch) => {\r\n\t\tcenterMass.left += (touch.clientX - left) / touches.length;\r\n\t\tcenterMass.top += (touch.clientY - top) / touches.length;\r\n\t});\r\n\r\n\ttouches.forEach((touch) => {\r\n\t\tspread += distance(\r\n\t\t\t{ x: centerMass.left, y: centerMass.top },\r\n\t\t\t{ x: touch.clientX - left, y: touch.clientY - top },\r\n\t\t);\r\n\t});\r\n\r\n\treturn { centerMass, spread, count: touches.length };\r\n}\r\n","<script>\r\nimport { ManipulateImageEvent } from '../../core/events.ts';\r\nimport { calculateGeometricProperties } from '../../core/touch';\r\nimport { sign } from '../../core/utils';\r\n\r\nexport default {\r\n\tname: 'CropperWrapper',\r\n\tprops: {\r\n\t\ttouchMove: {\r\n\t\t\ttype: Boolean,\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tmouseMove: {\r\n\t\t\ttype: Boolean,\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\ttouchResize: {\r\n\t\t\ttype: Boolean,\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\twheelResize: {\r\n\t\t\ttype: [Boolean, Object],\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n\tbeforeMount() {\r\n\t\twindow.addEventListener('mouseup', this.onMouseUp, { passive: false });\r\n\t\twindow.addEventListener('mousemove', this.onMouseMove, { passive: false });\r\n\t\twindow.addEventListener('touchmove', this.onTouchMove, { passive: false });\r\n\t\twindow.addEventListener('touchend', this.onTouchEnd, { passive: false });\r\n\t},\r\n\tbeforeDestroy() {\r\n\t\twindow.removeEventListener('mouseup', this.onMouseUp);\r\n\t\twindow.removeEventListener('mousemove', this.onMouseMove);\r\n\t\twindow.removeEventListener('touchmove', this.onTouchMove);\r\n\t\twindow.removeEventListener('touchend', this.onTouchEnd);\r\n\t},\r\n\tmounted() {\r\n\t\tthis.touches = [];\r\n\t},\r\n\tmethods: {\r\n\t\tonTouchStart(e) {\r\n\t\t\tif (e.cancelable && (this.touchMove || (this.touchResize && e.touches.length > 1))) {\r\n\t\t\t\tconst container = this.$refs.container;\r\n\t\t\t\tconst { left, top, bottom, right } = container.getBoundingClientRect();\r\n\t\t\t\tthis.touches = [...e.touches].filter(\r\n\t\t\t\t\t(touch) =>\r\n\t\t\t\t\t\ttouch.clientX > left && touch.clientX < right && touch.clientY > top && touch.clientY < bottom,\r\n\t\t\t\t);\r\n\t\t\t\tthis.oldGeometricProperties = calculateGeometricProperties(this.touches, container);\r\n\r\n\t\t\t\tif (e.preventDefault) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonTouchEnd(e) {\r\n\t\t\tif (e.touches.length === 0) {\r\n\t\t\t\tthis.processEnd();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonTouchMove(e) {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tconst touches = [...e.touches].filter(\r\n\t\t\t\t\t(touch) =>\r\n\t\t\t\t\t\t!touch.identifier ||\r\n\t\t\t\t\t\tthis.touches.find((anotherTouch) => anotherTouch.identifier === touch.identifier),\r\n\t\t\t\t);\r\n\t\t\t\tthis.processMove(e, touches);\r\n\t\t\t\tif (e.preventDefault) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\tif (e.stopPropagation) {\r\n\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseDown(e) {\r\n\t\t\tif (this.mouseMove && 'buttons' in e && e.buttons === 1) {\r\n\t\t\t\tconst touch = {\r\n\t\t\t\t\tfake: true,\r\n\t\t\t\t\tclientX: e.clientX,\r\n\t\t\t\t\tclientY: e.clientY,\r\n\t\t\t\t};\r\n\t\t\t\tthis.touches = [touch];\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseMove(e) {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tthis.processMove(e, [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfake: true,\r\n\t\t\t\t\t\tclientX: e.clientX,\r\n\t\t\t\t\t\tclientY: e.clientY,\r\n\t\t\t\t\t},\r\n\t\t\t\t]);\r\n\t\t\t\tif (e.preventDefault && e.cancelable) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonMouseUp() {\r\n\t\t\tthis.touches = [];\r\n\t\t},\r\n\t\tprocessMove(event, newTouches) {\r\n\t\t\tif (this.touches.length) {\r\n\t\t\t\tif (this.touches.length === 1 && newTouches.length === 1) {\r\n\t\t\t\t\tthis.$emit(\r\n\t\t\t\t\t\t'move',\r\n\t\t\t\t\t\tnew ManipulateImageEvent({\r\n\t\t\t\t\t\t\tleft: this.touches[0].clientX - newTouches[0].clientX,\r\n\t\t\t\t\t\t\ttop: this.touches[0].clientY - newTouches[0].clientY,\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t);\r\n\t\t\t\t} else if (this.touches.length > 1 && this.touchResize) {\r\n\t\t\t\t\tconst newProperties = calculateGeometricProperties(newTouches, this.$refs.container);\r\n\t\t\t\t\tconst oldProperties = this.oldGeometricProperties;\r\n\r\n\t\t\t\t\tif (oldProperties.count === newProperties.count && oldProperties.count > 1) {\r\n\t\t\t\t\t\tthis.$emit(\r\n\t\t\t\t\t\t\t'resize',\r\n\t\t\t\t\t\t\tnew ManipulateImageEvent(\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tleft: oldProperties.centerMass.left - newProperties.centerMass.left,\r\n\t\t\t\t\t\t\t\t\ttop: oldProperties.centerMass.top - newProperties.centerMass.top,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfactor: oldProperties.spread / newProperties.spread,\r\n\t\t\t\t\t\t\t\t\tcenter: newProperties.centerMass,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.oldGeometricProperties = newProperties;\r\n\t\t\t\t}\r\n\t\t\t\tthis.touches = newTouches;\r\n\t\t\t}\r\n\t\t},\r\n\t\tprocessEnd() {\r\n\t\t\tthis.touches = [];\r\n\t\t},\r\n\t\tonWheel(event) {\r\n\t\t\tif (this.wheelResize) {\r\n\t\t\t\tconst container = this.$refs.container;\r\n\t\t\t\tconst { left, top } = container.getBoundingClientRect();\r\n\t\t\t\tconst factor = 1 + this.wheelResize.ratio * sign(event.deltaY || event.detail || event.wheelDelta);\r\n\t\t\t\tconst center = {\r\n\t\t\t\t\tleft: event.clientX - left,\r\n\t\t\t\t\ttop: event.clientY - top,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tthis.$emit('resize', new ManipulateImageEvent({}, { factor, center }));\r\n\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t\tevent.stopPropagation();\r\n\t\t\t}\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<div ref=\"container\" @touchstart=\"onTouchStart\" @mousedown=\"onMouseDown\" @wheel=\"onWheel\">\r\n\t\t<slot />\r\n\t</div>\r\n</template>\r\n","<script>\r\nimport classnames from 'classnames';\r\nimport bem from 'easy-bem';\r\nimport debounce from 'debounce';\r\nimport { RectangleStencil } from './components/stencils';\r\nimport { CropperWrapper } from './components/service';\r\nimport {\r\n\tfillBoundaries,\r\n\tfitBoundaries,\r\n\tgetOptions,\r\n\tisBlob,\r\n\tisFunction,\r\n\tisLoadedImage,\r\n\tisNumber,\r\n\tisNumeric,\r\n\tisObject,\r\n\tlimitBy,\r\n\tradians,\r\n\treplacedProp,\r\n} from './core';\r\nimport { approximatedSize } from './core/algorithms';\r\nimport { updateCanvas } from './core/canvas';\r\nimport { ManipulateImageEvent } from './core/events';\r\nimport { isEqual, limitSizeRestrictions, limitsToSize, ratio } from './core/service';\r\nimport { isLocal, isCrossOriginURL, isUndefined, getSettings, parseNumber } from './core/utils';\r\nimport { arrayBufferToDataURL, getImageTransforms, getStyleTransforms, prepareSource, parseImage } from './core/image';\r\nimport { IMAGE_RESTRICTIONS, DEFAULT_COORDINATES } from './core/constants';\r\nimport * as algorithms from './core/algorithms';\r\n\r\nconst cn = bem('vue-advanced-cropper');\r\n\r\nexport default {\r\n\tname: 'Cropper',\r\n\tcomponents: {\r\n\t\tCropperWrapper,\r\n\t},\r\n\tprops: {\r\n\t\tsrc: {\r\n\t\t\ttype: String,\r\n\t\t\tdefault: null,\r\n\t\t},\r\n\t\tstencilComponent: {\r\n\t\t\ttype: [Object, String],\r\n\t\t\tdefault() {\r\n\t\t\t\treturn RectangleStencil;\r\n\t\t\t},\r\n\t\t},\r\n\t\tstencilProps: {\r\n\t\t\ttype: Object,\r\n\t\t\tdefault() {\r\n\t\t\t\treturn {};\r\n\t\t\t},\r\n\t\t},\r\n\t\tautoZoom: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t\timageClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\tboundariesClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\tbackgroundClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\tforegroundClass: {\r\n\t\t\ttype: String,\r\n\t\t},\r\n\t\tminWidth: {\r\n\t\t\ttype: [Number, String],\r\n\t\t},\r\n\t\tminHeight: {\r\n\t\t\ttype: [Number, String],\r\n\t\t},\r\n\t\tmaxWidth: {\r\n\t\t\ttype: [Number, String],\r\n\t\t},\r\n\t\tmaxHeight: {\r\n\t\t\ttype: [Number, String],\r\n\t\t},\r\n\t\tdebounce: {\r\n\t\t\ttype: [Boolean, Number],\r\n\t\t\tdefault: 500,\r\n\t\t},\r\n\t\ttransitions: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: true,\r\n\t\t},\r\n\t\tcheckOrientation: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: true,\r\n\t\t},\r\n\t\tcanvas: {\r\n\t\t\ttype: [Object, Boolean],\r\n\t\t\tdefault: true,\r\n\t\t},\r\n\t\tcrossOrigin: {\r\n\t\t\ttype: [Boolean, String],\r\n\t\t\tdefault: undefined,\r\n\t\t},\r\n\t\ttransitionTime: {\r\n\t\t\ttype: Number,\r\n\t\t\tdefault: 300,\r\n\t\t},\r\n\t\timageRestriction: {\r\n\t\t\ttype: String,\r\n\t\t\tdefault: 'fit-area',\r\n\t\t\tvalidator(value) {\r\n\t\t\t\treturn IMAGE_RESTRICTIONS.indexOf(value) !== -1;\r\n\t\t\t},\r\n\t\t},\r\n\t\troundResult: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: true,\r\n\t\t},\r\n\t\tdefaultSize: {\r\n\t\t\ttype: [Function, Object],\r\n\t\t},\r\n\t\tdefaultPosition: {\r\n\t\t\ttype: [Function, Object],\r\n\t\t\tdefault: algorithms.defaultPosition,\r\n\t\t},\r\n\t\tdefaultVisibleArea: {\r\n\t\t\ttype: [Function, Object],\r\n\t\t\tdefault: algorithms.defaultVisibleArea,\r\n\t\t},\r\n\t\tdefaultBoundaries: {\r\n\t\t\ttype: [Function, String],\r\n\t\t\tvalidator(value) {\r\n\t\t\t\tconst invalid = typeof value === 'string' && value !== 'fill' && value !== 'fit';\r\n\t\t\t\tif (invalid) {\r\n\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\t\t`Warning: prop \"defaultBoundaries\" gets incorrect string value ${value}. It should be either function, 'fill' or 'fit'`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn !invalid;\r\n\t\t\t},\r\n\t\t},\r\n\t\tpriority: {\r\n\t\t\ttype: String,\r\n\t\t\tdefault: 'coordinates',\r\n\t\t},\r\n\t\tstencilSize: {\r\n\t\t\ttype: [Object, Function],\r\n\t\t},\r\n\t\tresizeImage: {\r\n\t\t\ttype: [Boolean, Object],\r\n\t\t\tdefault: true,\r\n\t\t},\r\n\t\tmoveImage: {\r\n\t\t\ttype: [Boolean, Object],\r\n\t\t\tdefault: true,\r\n\t\t},\r\n\t\tautoZoomAlgorithm: {\r\n\t\t\ttype: Function,\r\n\t\t},\r\n\t\tresizeAlgorithm: {\r\n\t\t\ttype: Function,\r\n\t\t\tdefault: algorithms.resize,\r\n\t\t},\r\n\t\tmoveAlgorithm: {\r\n\t\t\ttype: Function,\r\n\t\t\tdefault: algorithms.move,\r\n\t\t},\r\n\t\tinitStretcher: {\r\n\t\t\ttype: Function,\r\n\t\t\tdefault: algorithms.initStretcher,\r\n\t\t},\r\n\t\tfitCoordinates: {\r\n\t\t\ttype: Function,\r\n\t\t\tdefault: algorithms.fitCoordinates,\r\n\t\t},\r\n\t\tfitVisibleArea: {\r\n\t\t\ttype: Function,\r\n\t\t\tdefault: algorithms.fitVisibleArea,\r\n\t\t},\r\n\t\tareaRestrictionsAlgorithm: {\r\n\t\t\ttype: Function,\r\n\t\t\tdefault: algorithms.dynamicAreaRestrictions,\r\n\t\t},\r\n\t\tsizeRestrictionsAlgorithm: {\r\n\t\t\ttype: Function,\r\n\t\t\tdefault: algorithms.pixelsRestrictions,\r\n\t\t},\r\n\t\tpositionRestrictionsAlgorithm: {\r\n\t\t\ttype: Function,\r\n\t\t\tdefault: algorithms.positionRestrictions,\r\n\t\t},\r\n\t},\r\n\tdata() {\r\n\t\treturn {\r\n\t\t\ttransitionsActive: false,\r\n\t\t\timageLoaded: false,\r\n\t\t\timageAttributes: {\r\n\t\t\t\twidth: null,\r\n\t\t\t\theight: null,\r\n\t\t\t\tcrossOrigin: false,\r\n\t\t\t\tsrc: null,\r\n\t\t\t},\r\n\t\t\tcustomImageTransforms: {\r\n\t\t\t\trotate: 0,\r\n\t\t\t\tflip: {\r\n\t\t\t\t\thorizontal: false,\r\n\t\t\t\t\tvertical: false,\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tbasicImageTransforms: {\r\n\t\t\t\trotate: 0,\r\n\t\t\t\tflip: {\r\n\t\t\t\t\thorizontal: false,\r\n\t\t\t\t\tvertical: false,\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tboundaries: {\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0,\r\n\t\t\t},\r\n\t\t\tvisibleArea: null,\r\n\t\t\tcoordinates: {\r\n\t\t\t\t...DEFAULT_COORDINATES,\r\n\t\t\t},\r\n\t\t};\r\n\t},\r\n\tcomputed: {\r\n\t\timage() {\r\n\t\t\treturn {\r\n\t\t\t\tsrc: this.imageAttributes.src,\r\n\t\t\t\twidth: this.imageAttributes.width,\r\n\t\t\t\theight: this.imageAttributes.height,\r\n\t\t\t\ttransforms: this.imageTransforms,\r\n\t\t\t};\r\n\t\t},\r\n\t\timageTransforms() {\r\n\t\t\treturn {\r\n\t\t\t\trotate: this.basicImageTransforms.rotate + this.customImageTransforms.rotate,\r\n\t\t\t\tflip: {\r\n\t\t\t\t\thorizontal: Boolean(\r\n\t\t\t\t\t\tthis.basicImageTransforms.flip.horizontal ^ this.customImageTransforms.flip.horizontal,\r\n\t\t\t\t\t),\r\n\t\t\t\t\tvertical: Boolean(\r\n\t\t\t\t\t\tthis.basicImageTransforms.flip.vertical ^ this.customImageTransforms.flip.vertical,\r\n\t\t\t\t\t),\r\n\t\t\t\t},\r\n\t\t\t\ttranslateX: this.visibleArea ? this.visibleArea.left / this.coefficient : 0,\r\n\t\t\t\ttranslateY: this.visibleArea ? this.visibleArea.top / this.coefficient : 0,\r\n\t\t\t\tscaleX: 1 / this.coefficient,\r\n\t\t\t\tscaleY: 1 / this.coefficient,\r\n\t\t\t};\r\n\t\t},\r\n\t\timageSize() {\r\n\t\t\tconst transforms = this.imageTransforms;\r\n\t\t\tconst angle = radians(transforms.rotate);\r\n\t\t\treturn {\r\n\t\t\t\twidth:\r\n\t\t\t\t\tMath.abs(this.imageAttributes.width * Math.cos(angle)) +\r\n\t\t\t\t\tMath.abs(this.imageAttributes.height * Math.sin(angle)),\r\n\t\t\t\theight:\r\n\t\t\t\t\tMath.abs(this.imageAttributes.width * Math.sin(angle)) +\r\n\t\t\t\t\tMath.abs(this.imageAttributes.height * Math.cos(angle)),\r\n\t\t\t};\r\n\t\t},\r\n\t\tinitialized() {\r\n\t\t\treturn Boolean(this.visibleArea && this.imageLoaded);\r\n\t\t},\r\n\t\tsettings() {\r\n\t\t\tconst resizeImage = getOptions(\r\n\t\t\t\tthis.resizeImage,\r\n\t\t\t\t{\r\n\t\t\t\t\ttouch: true,\r\n\t\t\t\t\twheel: {\r\n\t\t\t\t\t\tratio: 0.1,\r\n\t\t\t\t\t},\r\n\t\t\t\t\tadjustStencil: true,\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\ttouch: false,\r\n\t\t\t\t\twheel: false,\r\n\t\t\t\t\tadjustStencil: false,\r\n\t\t\t\t},\r\n\t\t\t);\r\n\r\n\t\t\tconst moveImage = getOptions(\r\n\t\t\t\tthis.moveImage,\r\n\t\t\t\t{\r\n\t\t\t\t\ttouch: true,\r\n\t\t\t\t\tmouse: true,\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\ttouch: false,\r\n\t\t\t\t\tmouse: false,\r\n\t\t\t\t},\r\n\t\t\t);\r\n\r\n\t\t\treturn {\r\n\t\t\t\tmoveImage,\r\n\t\t\t\tresizeImage,\r\n\t\t\t};\r\n\t\t},\r\n\t\tcoefficient() {\r\n\t\t\treturn this.visibleArea ? this.visibleArea.width / this.boundaries.width : 0;\r\n\t\t},\r\n\t\tareaRestrictions() {\r\n\t\t\tif (this.imageLoaded) {\r\n\t\t\t\treturn this.areaRestrictionsAlgorithm({\r\n\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\timageRestriction: this.imageRestriction,\r\n\t\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn {};\r\n\t\t\t}\r\n\t\t},\r\n\t\ttransitionsOptions() {\r\n\t\t\treturn {\r\n\t\t\t\tenabled: this.transitionsActive,\r\n\t\t\t\ttimingFunction: 'ease-in-out',\r\n\t\t\t\ttime: 350,\r\n\t\t\t};\r\n\t\t},\r\n\t\tsizeRestrictions() {\r\n\t\t\tif (this.boundaries.width && this.boundaries.height && this.imageSize.width && this.imageSize.height) {\r\n\t\t\t\tlet sizeRestrictions = this.sizeRestrictionsAlgorithm({\r\n\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\tminWidth: !isUndefined(this.minWidth) ? parseNumber(this.minWidth) : 0,\r\n\t\t\t\t\tminHeight: !isUndefined(this.minHeight) ? parseNumber(this.minHeight) : 0,\r\n\t\t\t\t\tmaxWidth: !isUndefined(this.maxWidth) ? parseNumber(this.maxWidth) : Infinity,\r\n\t\t\t\t\tmaxHeight: !isUndefined(this.maxHeight) ? parseNumber(this.maxHeight) : Infinity,\r\n\t\t\t\t});\r\n\r\n\t\t\t\tsizeRestrictions = algorithms.refineSizeRestrictions({\r\n\t\t\t\t\tsizeRestrictions,\r\n\t\t\t\t\tareaRestrictions: this.getAreaRestrictions({ visibleArea: this.visibleArea, type: 'resize' }),\r\n\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\t\tpositionRestrictions: this.positionRestrictions,\r\n\t\t\t\t\timageRestriction: this.imageRestriction,\r\n\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\tstencilSize: this.getStencilSize(),\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (this.visibleArea && this.stencilSize) {\r\n\t\t\t\t\tconst stencilSize = this.getStencilSize();\r\n\t\t\t\t\tconst areaRestrictions = limitsToSize(\r\n\t\t\t\t\t\tthis.getAreaRestrictions({ visibleArea: this.visibleArea, type: 'resize' }),\r\n\t\t\t\t\t);\r\n\t\t\t\t\tsizeRestrictions.maxWidth = Math.min(\r\n\t\t\t\t\t\tsizeRestrictions.maxWidth,\r\n\t\t\t\t\t\t(areaRestrictions.width * stencilSize.width) / this.boundaries.width,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tsizeRestrictions.maxHeight = Math.min(\r\n\t\t\t\t\t\tsizeRestrictions.maxHeight,\r\n\t\t\t\t\t\t(areaRestrictions.height * stencilSize.height) / this.boundaries.height,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (sizeRestrictions.maxWidth < sizeRestrictions.minWidth) {\r\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\t\t\t'Maximum width is smaller than minimum width, because otherwise the area restrictions or stencil size will be broken. Minimum width is reduced.',\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsizeRestrictions.minWidth = sizeRestrictions.maxWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (sizeRestrictions.maxHeight < sizeRestrictions.minHeight) {\r\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\t\t\t'Maximum height is smaller than minimum height, because otherwise the area restrictions or stencil size will be broken. Minimum height is reduced.',\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsizeRestrictions.minHeight = sizeRestrictions.maxHeight;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn sizeRestrictions;\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tminWidth: 0,\r\n\t\t\t\t\tminHeight: 0,\r\n\t\t\t\t\tmaxWidth: 0,\r\n\t\t\t\t\tmaxHeight: 0,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\tpositionRestrictions() {\r\n\t\t\treturn this.positionRestrictionsAlgorithm({\r\n\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\timageRestriction: this.imageRestriction,\r\n\t\t\t});\r\n\t\t},\r\n\t\t// Styling\r\n\t\tclasses() {\r\n\t\t\treturn {\r\n\t\t\t\tcropper: cn(),\r\n\t\t\t\timage: classnames(cn('image'), this.imageClass),\r\n\t\t\t\tstencil: cn('stencil'),\r\n\t\t\t\tboundaries: classnames(cn('boundaries'), this.boundariesClass),\r\n\t\t\t\tstretcher: classnames(cn('stretcher')),\r\n\t\t\t\tbackground: classnames(cn('background'), this.backgroundClass),\r\n\t\t\t\tforeground: classnames(cn('foreground'), this.foregroundClass),\r\n\t\t\t\timageWrapper: classnames(cn('image-wrapper')),\r\n\t\t\t\tcropperWrapper: classnames(cn('cropper-wrapper')),\r\n\t\t\t};\r\n\t\t},\r\n\t\tstencilCoordinates() {\r\n\t\t\tif (this.initialized) {\r\n\t\t\t\tconst { width, height, left, top } = this.coordinates;\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth: width / this.coefficient,\r\n\t\t\t\t\theight: height / this.coefficient,\r\n\t\t\t\t\tleft: (left - this.visibleArea.left) / this.coefficient,\r\n\t\t\t\t\ttop: (top - this.visibleArea.top) / this.coefficient,\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\treturn this.defaultCoordinates();\r\n\t\t\t}\r\n\t\t},\r\n\t\tboundariesStyle() {\r\n\t\t\tconst styles = {\r\n\t\t\t\twidth: this.boundaries.width ? `${Math.round(this.boundaries.width)}px` : 'auto',\r\n\t\t\t\theight: this.boundaries.height ? `${Math.round(this.boundaries.height)}px` : 'auto',\r\n\t\t\t\ttransition: `opacity ${this.transitionTime}ms`,\r\n\t\t\t\tpointerEvents: this.imageLoaded ? 'all' : 'none',\r\n\t\t\t};\r\n\t\t\tif (!this.imageLoaded) {\r\n\t\t\t\tstyles.opacity = '0';\r\n\t\t\t}\r\n\t\t\treturn styles;\r\n\t\t},\r\n\t\timageStyle() {\r\n\t\t\tconst optimalImageSize =\r\n\t\t\t\tthis.imageAttributes.width > this.imageAttributes.height\r\n\t\t\t\t\t? {\r\n\t\t\t\t\t\t\twidth: Math.min(1024, this.imageAttributes.width),\r\n\t\t\t\t\t\t\theight:\r\n\t\t\t\t\t\t\t\tMath.min(1024, this.imageAttributes.width) /\r\n\t\t\t\t\t\t\t\t(this.imageAttributes.width / this.imageAttributes.height),\r\n\t\t\t\t\t  }\r\n\t\t\t\t\t: {\r\n\t\t\t\t\t\t\theight: Math.min(1024, this.imageAttributes.height),\r\n\t\t\t\t\t\t\twidth:\r\n\t\t\t\t\t\t\t\tMath.min(1024, this.imageAttributes.height) *\r\n\t\t\t\t\t\t\t\t(this.imageAttributes.width / this.imageAttributes.height),\r\n\t\t\t\t\t  };\r\n\r\n\t\t\tconst compensations = {\r\n\t\t\t\trotate: {\r\n\t\t\t\t\tleft: (optimalImageSize.width - this.imageSize.width) / (2 * this.coefficient),\r\n\t\t\t\t\ttop: (optimalImageSize.height - this.imageSize.height) / (2 * this.coefficient),\r\n\t\t\t\t},\r\n\t\t\t\tscale: {\r\n\t\t\t\t\tleft: ((1 - 1 / this.coefficient) * optimalImageSize.width) / 2,\r\n\t\t\t\t\ttop: ((1 - 1 / this.coefficient) * optimalImageSize.height) / 2,\r\n\t\t\t\t},\r\n\t\t\t};\r\n\r\n\t\t\tconst transforms = {\r\n\t\t\t\t...this.imageTransforms,\r\n\t\t\t\tscaleX: this.imageTransforms.scaleX * (this.imageAttributes.width / optimalImageSize.width),\r\n\t\t\t\tscaleY: this.imageTransforms.scaleY * (this.imageAttributes.height / optimalImageSize.height),\r\n\t\t\t};\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\twidth: `${optimalImageSize.width}px`,\r\n\t\t\t\theight: `${optimalImageSize.height}px`,\r\n\t\t\t\tleft: '0px',\r\n\t\t\t\ttop: '0px',\r\n\t\t\t\ttransform:\r\n\t\t\t\t\t`translate(${\r\n\t\t\t\t\t\t-compensations.rotate.left - compensations.scale.left - this.imageTransforms.translateX\r\n\t\t\t\t\t}px, ${-compensations.rotate.top - compensations.scale.top - this.imageTransforms.translateY}px)` +\r\n\t\t\t\t\tgetStyleTransforms(transforms),\r\n\t\t\t};\r\n\r\n\t\t\tif (this.transitionsOptions.enabled) {\r\n\t\t\t\tresult.transition = `${this.transitionsOptions.time}ms ${this.transitionsOptions.timingFunction}`;\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t},\r\n\twatch: {\r\n\t\tsrc() {\r\n\t\t\tthis.onChangeImage();\r\n\t\t},\r\n\t\tstencilComponent() {\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.resetCoordinates();\r\n\t\t\t\tthis.runAutoZoom('setCoordinates');\r\n\t\t\t\tthis.onChange();\r\n\t\t\t});\r\n\t\t},\r\n\t\tminWidth() {\r\n\t\t\tthis.onPropsChange();\r\n\t\t},\r\n\t\tmaxWidth() {\r\n\t\t\tthis.onPropsChange();\r\n\t\t},\r\n\t\tminHeight() {\r\n\t\t\tthis.onPropsChange();\r\n\t\t},\r\n\t\tmaxHeight() {\r\n\t\t\tthis.onPropsChange();\r\n\t\t},\r\n\t\timageRestriction() {\r\n\t\t\tthis.reset();\r\n\t\t},\r\n\t\tstencilProps(oldProps, newProps) {\r\n\t\t\tconst significantProps = ['aspectRatio', 'minAspectRatio', 'maxAspectRatio'];\r\n\t\t\tif (significantProps.find((prop) => oldProps[prop] !== newProps[prop])) {\r\n\t\t\t\tthis.$nextTick(this.onPropsChange);\r\n\t\t\t}\r\n\t\t},\r\n\t},\r\n\tcreated() {\r\n\t\tthis.debouncedUpdate = debounce(this.update, this.debounce);\r\n\t\tthis.debouncedDisableTransitions = debounce(this.disableTransitions, this.transitionsOptions.time);\r\n\t\tthis.awaiting = false;\r\n\t},\r\n\tmounted() {\r\n\t\tthis.$refs.image.addEventListener('load', this.onSuccessLoadImage);\r\n\t\tthis.$refs.image.addEventListener('error', this.onFailLoadImage);\r\n\t\tthis.onChangeImage();\r\n\r\n\t\t// Add listeners to window to adapt the cropper to window changes\r\n\t\twindow.addEventListener('resize', this.refresh);\r\n\t\twindow.addEventListener('orientationchange', this.refresh);\r\n\t},\r\n\tdestroyed() {\r\n\t\twindow.removeEventListener('resize', this.refresh);\r\n\t\twindow.removeEventListener('orientationchange', this.refresh);\r\n\t\tif (this.imageAttributes.revoke && this.imageAttributes.src) {\r\n\t\t\tURL.revokeObjectURL(this.imageAttributes.src);\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\t// External methods\r\n\t\tgetResult() {\r\n\t\t\tconst coordinates = this.initialized\r\n\t\t\t\t? this.prepareResult({ ...this.coordinates })\r\n\t\t\t\t: this.defaultCoordinates();\r\n\t\t\tconst imageTransforms = {\r\n\t\t\t\trotate: this.imageTransforms.rotate % 360,\r\n\t\t\t\tflip: {\r\n\t\t\t\t\t...this.imageTransforms.flip,\r\n\t\t\t\t},\r\n\t\t\t};\r\n\t\t\tif (this.src && this.imageLoaded) {\r\n\t\t\t\tconst cropper = this;\r\n\t\t\t\treturn {\r\n\t\t\t\t\timage: this.image,\r\n\t\t\t\t\tcoordinates,\r\n\t\t\t\t\tvisibleArea: this.visibleArea ? { ...this.visibleArea } : null,\r\n\t\t\t\t\timageTransforms,\r\n\t\t\t\t\tget canvas() {\r\n\t\t\t\t\t\tif (cropper.canvas) {\r\n\t\t\t\t\t\t\treturn cropper.getCanvas();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\timage: this.image,\r\n\t\t\t\t\tcoordinates,\r\n\t\t\t\t\tvisibleArea: this.visibleArea ? { ...this.visibleArea } : null,\r\n\t\t\t\t\tcanvas: undefined,\r\n\t\t\t\t\timageTransforms,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\tzoom(factor, center, params = {}) {\r\n\t\t\tconst { transitions = true } = params;\r\n\r\n\t\t\tthis.onManipulateImage(\r\n\t\t\t\tnew ManipulateImageEvent(\r\n\t\t\t\t\t{},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfactor: 1 / factor,\r\n\t\t\t\t\t\tcenter,\r\n\t\t\t\t\t},\r\n\t\t\t\t),\r\n\t\t\t\t{\r\n\t\t\t\t\tnormalize: false,\r\n\t\t\t\t\ttransitions,\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t},\r\n\t\tmove(left, top, params = {}) {\r\n\t\t\tconst { transitions = true } = params;\r\n\r\n\t\t\tthis.onManipulateImage(\r\n\t\t\t\tnew ManipulateImageEvent({\r\n\t\t\t\t\tleft: left || 0,\r\n\t\t\t\t\ttop: top || 0,\r\n\t\t\t\t}),\r\n\t\t\t\t{\r\n\t\t\t\t\tnormalize: false,\r\n\t\t\t\t\ttransitions,\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t},\r\n\t\tsetCoordinates(transforms, params = {}) {\r\n\t\t\tconst { autoZoom = true, transitions = true } = params;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tif (!this.imageLoaded) {\r\n\t\t\t\t\tthis.delayedTransforms = transforms;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!this.transitionsActive) {\r\n\t\t\t\t\t\tif (transitions) {\r\n\t\t\t\t\t\t\tthis.enableTransitions();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.coordinates = this.applyTransform(transforms);\r\n\t\t\t\t\t\tif (autoZoom) {\r\n\t\t\t\t\t\t\tthis.runAutoZoom('setCoordinates');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (transitions) {\r\n\t\t\t\t\t\t\tthis.debouncedDisableTransitions();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.onChange();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\trefresh() {\r\n\t\t\tconst image = this.$refs.image;\r\n\t\t\tif (this.src && image) {\r\n\t\t\t\tlet promise;\r\n\t\t\t\tif (this.initialized) {\r\n\t\t\t\t\treturn this.updateVisibleArea().then(() => {\r\n\t\t\t\t\t\tthis.onChange();\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.resetVisibleArea().then(() => {\r\n\t\t\t\t\t\tthis.onChange();\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\treset() {\r\n\t\t\treturn this.resetVisibleArea().then(() => {\r\n\t\t\t\tthis.onChange();\r\n\t\t\t});\r\n\t\t},\r\n\t\t// Internal methods\r\n\t\tawaitRender(callback) {\r\n\t\t\tif (!this.awaiting) {\r\n\t\t\t\tthis.awaiting = true;\r\n\t\t\t\tthis.$nextTick(() => {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t\tthis.awaiting = false;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\tprepareResult(coordinates) {\r\n\t\t\tif (this.roundResult) {\r\n\t\t\t\treturn algorithms.roundCoordinates({\r\n\t\t\t\t\t...this.getPublicProperties(),\r\n\t\t\t\t\tpositionRestrictions: algorithms.limitBy(this.positionRestrictions, this.visibleArea),\r\n\t\t\t\t\tcoordinates,\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn coordinates;\r\n\t\t\t}\r\n\t\t},\r\n\t\tprocessAutoZoom(type, visibleArea, coordinates, params) {\r\n\t\t\tlet algorithm = this.autoZoomAlgorithm;\r\n\r\n\t\t\tif (!algorithm) {\r\n\t\t\t\tif (this.stencilSize) {\r\n\t\t\t\t\talgorithm = algorithms.fixedStencilAutoZoom;\r\n\t\t\t\t} else if (this.autoZoom) {\r\n\t\t\t\t\talgorithm = algorithms.hybridStencilAutoZoom;\r\n\t\t\t\t} else {\r\n\t\t\t\t\talgorithm = algorithms.simplestAutoZoom;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tconst result = algorithm({\r\n\t\t\t\tevent: {\r\n\t\t\t\t\ttype,\r\n\t\t\t\t\tparams,\r\n\t\t\t\t},\r\n\t\t\t\tvisibleArea,\r\n\t\t\t\tcoordinates,\r\n\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\taspectRatio: this.getAspectRatio(),\r\n\t\t\t\tpositionRestrictions: this.positionRestrictions,\r\n\t\t\t\tgetAreaRestrictions: this.getAreaRestrictions,\r\n\t\t\t\tsizeRestrictions: this.sizeRestrictions,\r\n\t\t\t\tstencilSize: this.getStencilSize(),\r\n\t\t\t});\r\n\r\n\t\t\treturn {\r\n\t\t\t\t...result,\r\n\t\t\t\tchanged: !isEqual(result.visibleArea, visibleArea) || !isEqual(result.coordinates, coordinates),\r\n\t\t\t};\r\n\t\t},\r\n\t\trunAutoZoom(event, params = {}) {\r\n\t\t\tconst { transitions = false, ...payload } = params;\r\n\r\n\t\t\tconst { visibleArea, coordinates, changed } = this.processAutoZoom(\r\n\t\t\t\tevent,\r\n\t\t\t\tthis.visibleArea,\r\n\t\t\t\tthis.coordinates,\r\n\t\t\t\tpayload,\r\n\t\t\t);\r\n\r\n\t\t\tif (transitions && changed) {\r\n\t\t\t\tthis.enableTransitions();\r\n\t\t\t}\r\n\r\n\t\t\tthis.visibleArea = visibleArea;\r\n\t\t\tthis.coordinates = coordinates;\r\n\r\n\t\t\tif (transitions && changed) {\r\n\t\t\t\tthis.debouncedDisableTransitions();\r\n\t\t\t}\r\n\t\t},\r\n\t\tnormalizeEvent(event) {\r\n\t\t\treturn algorithms.normalizeEvent({\r\n\t\t\t\t...this.getPublicProperties(),\r\n\t\t\t\tevent,\r\n\t\t\t});\r\n\t\t},\r\n\t\tgetCanvas() {\r\n\t\t\t// This function can be asynchronously called because it's debounced\r\n\t\t\t// Therefore there is workaround to prevent processing after the component was unmounted\r\n\t\t\tif (this.$refs.canvas) {\r\n\t\t\t\tconst canvas = this.$refs.canvas;\r\n\t\t\t\tconst image = this.$refs.image;\r\n\t\t\t\tconst imageTransformed =\r\n\t\t\t\t\tthis.imageTransforms.rotate !== 0 ||\r\n\t\t\t\t\tthis.imageTransforms.flip.horizontal ||\r\n\t\t\t\t\tthis.imageTransforms.flip.vertical;\r\n\t\t\t\tconst source = imageTransformed\r\n\t\t\t\t\t? prepareSource(this.$refs.sourceCanvas, image, this.imageTransforms)\r\n\t\t\t\t\t: image;\r\n\r\n\t\t\t\tconst options = {\r\n\t\t\t\t\tminWidth: 0,\r\n\t\t\t\t\tminHeight: 0,\r\n\t\t\t\t\tmaxWidth: Infinity,\r\n\t\t\t\t\tmaxHeight: Infinity,\r\n\t\t\t\t\tmaxArea: this.maxCanvasSize,\r\n\t\t\t\t\timageSmoothingEnabled: true,\r\n\t\t\t\t\timageSmoothingQuality: 'high',\r\n\t\t\t\t\tfillColor: 'transparent',\r\n\t\t\t\t\t...this.canvas,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tconst firstNumeric = (array) => array.find((el) => isNumeric(el));\r\n\r\n\t\t\t\tlet size = approximatedSize({\r\n\t\t\t\t\tsizeRestrictions: {\r\n\t\t\t\t\t\tminWidth: firstNumeric([options.width, options.minWidth]) || 0,\r\n\t\t\t\t\t\tminHeight: firstNumeric([options.height, options.minHeight]) || 0,\r\n\t\t\t\t\t\tmaxWidth: firstNumeric([options.width, options.maxWidth]) || Infinity,\r\n\t\t\t\t\t\tmaxHeight: firstNumeric([options.height, options.maxHeight]) || Infinity,\r\n\t\t\t\t\t},\r\n\t\t\t\t\twidth: this.coordinates.width,\r\n\t\t\t\t\theight: this.coordinates.height,\r\n\t\t\t\t\taspectRatio: {\r\n\t\t\t\t\t\tminimum: this.coordinates.width / this.coordinates.height,\r\n\t\t\t\t\t\tmaximum: this.coordinates.width / this.coordinates.height,\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (options.maxArea && size.width * size.height > options.maxArea) {\r\n\t\t\t\t\tconst scale = Math.sqrt(options.maxArea / (size.width * size.height));\r\n\t\t\t\t\tsize = {\r\n\t\t\t\t\t\twidth: Math.round(scale * size.width),\r\n\t\t\t\t\t\theight: Math.round(scale * size.height),\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tupdateCanvas(canvas, source, this.coordinates, size, options);\r\n\r\n\t\t\t\treturn canvas;\r\n\t\t\t}\r\n\t\t},\r\n\t\tupdate() {\r\n\t\t\tthis.$emit('change', this.getResult());\r\n\t\t},\r\n\t\tapplyTransform(transform, limited = false) {\r\n\t\t\tconst sizeRestrictions =\r\n\t\t\t\tthis.visibleArea && limited\r\n\t\t\t\t\t? limitSizeRestrictions(this.sizeRestrictions, this.visibleArea)\r\n\t\t\t\t\t: this.sizeRestrictions;\r\n\r\n\t\t\tconst positionRestrictions =\r\n\t\t\t\tthis.visibleArea && limited\r\n\t\t\t\t\t? limitBy(this.positionRestrictions, this.visibleArea)\r\n\t\t\t\t\t: this.positionRestrictions;\r\n\r\n\t\t\treturn algorithms.applyTransform({\r\n\t\t\t\ttransform,\r\n\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\tsizeRestrictions,\r\n\t\t\t\tpositionRestrictions,\r\n\t\t\t\taspectRatio: this.getAspectRatio(),\r\n\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t});\r\n\t\t},\r\n\t\tresetCoordinates() {\r\n\t\t\t// This function can be asynchronously called after completion of refreshing image promise\r\n\t\t\t// Therefore there is a workaround to prevent processing after the component was unmounted\r\n\t\t\t// Also coordinates can't be reset if visible area was not initialized\r\n\t\t\tif (this.$refs.image) {\r\n\t\t\t\tconst cropper = this.$refs.cropper;\r\n\t\t\t\tconst image = this.$refs.image;\r\n\r\n\t\t\t\tlet defaultSizeAlgorithm = this.defaultSize;\r\n\t\t\t\tif (!defaultSizeAlgorithm) {\r\n\t\t\t\t\tif (this.stencilSize) {\r\n\t\t\t\t\t\tdefaultSizeAlgorithm = algorithms.fixedDefaultSize;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdefaultSizeAlgorithm = algorithms.defaultSize;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst { minWidth, minHeight, maxWidth, maxHeight } = this.sizeRestrictions;\r\n\r\n\t\t\t\tconst defaultSize = isFunction(defaultSizeAlgorithm)\r\n\t\t\t\t\t? defaultSizeAlgorithm({\r\n\t\t\t\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\t\t\taspectRatio: this.getAspectRatio(),\r\n\t\t\t\t\t\t\tsizeRestrictions: this.sizeRestrictions,\r\n\t\t\t\t\t\t\tstencilSize: this.getStencilSize(),\r\n\t\t\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\t  })\r\n\t\t\t\t\t: defaultSizeAlgorithm;\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tprocess.env.NODE_ENV === 'development' &&\r\n\t\t\t\t\t(defaultSize.width < minWidth ||\r\n\t\t\t\t\t\tdefaultSize.height < minHeight ||\r\n\t\t\t\t\t\tdefaultSize.width > maxWidth ||\r\n\t\t\t\t\t\tdefaultSize.height > maxHeight)\r\n\t\t\t\t) {\r\n\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\t'Warning: the default size breaks size restrictions. Check your defaultSize function',\r\n\t\t\t\t\t\tdefaultSize,\r\n\t\t\t\t\t\tthis.sizeRestrictions,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst transforms = [\r\n\t\t\t\t\tdefaultSize,\r\n\t\t\t\t\t({ coordinates }) => ({\r\n\t\t\t\t\t\t...(isFunction(this.defaultPosition)\r\n\t\t\t\t\t\t\t? this.defaultPosition({\r\n\t\t\t\t\t\t\t\t\tcoordinates,\r\n\t\t\t\t\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\t\t\t  })\r\n\t\t\t\t\t\t\t: this.defaultPosition),\r\n\t\t\t\t\t}),\r\n\t\t\t\t];\r\n\r\n\t\t\t\tif (this.delayedTransforms) {\r\n\t\t\t\t\ttransforms.push(\r\n\t\t\t\t\t\t...(Array.isArray(this.delayedTransforms) ? this.delayedTransforms : [this.delayedTransforms]),\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tthis.coordinates = this.applyTransform(transforms, true);\r\n\t\t\t\tthis.delayedTransforms = null;\r\n\t\t\t}\r\n\t\t},\r\n\t\tclearImage() {\r\n\t\t\tthis.imageLoaded = false;\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tconst stretcher = this.$refs.stretcher;\r\n\t\t\t\tif (stretcher) {\r\n\t\t\t\t\tstretcher.style.height = 'auto';\r\n\t\t\t\t\tstretcher.style.width = 'auto';\r\n\t\t\t\t}\r\n\t\t\t\tthis.coordinates = this.defaultCoordinates();\r\n\t\t\t\tthis.boundaries = {\r\n\t\t\t\t\twidth: 0,\r\n\t\t\t\t\theight: 0,\r\n\t\t\t\t};\r\n\t\t\t}, this.transitionTime);\r\n\t\t},\r\n\t\tenableTransitions() {\r\n\t\t\tif (this.transitions) {\r\n\t\t\t\tthis.transitionsActive = true;\r\n\t\t\t}\r\n\t\t},\r\n\t\tdisableTransitions() {\r\n\t\t\tthis.transitionsActive = false;\r\n\t\t},\r\n\t\tupdateBoundaries() {\r\n\t\t\tconst stretcher = this.$refs.stretcher;\r\n\t\t\tconst cropper = this.$refs.cropper;\r\n\r\n\t\t\tthis.initStretcher({\r\n\t\t\t\tcropper,\r\n\t\t\t\tstretcher,\r\n\t\t\t\timageSize: this.imageSize,\r\n\t\t\t});\r\n\r\n\t\t\treturn this.$nextTick().then(() => {\r\n\t\t\t\tconst params = {\r\n\t\t\t\t\tcropper,\r\n\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (isFunction(this.defaultBoundaries)) {\r\n\t\t\t\t\tthis.boundaries = this.defaultBoundaries(params);\r\n\t\t\t\t} else if (this.defaultBoundaries === 'fit') {\r\n\t\t\t\t\tthis.boundaries = fitBoundaries(params);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.boundaries = fillBoundaries(params);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!this.boundaries.width || !this.boundaries.height) {\r\n\t\t\t\t\tthrow new Error(\"It's impossible to fit the cropper in the current container\");\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\tresetVisibleArea() {\r\n\t\t\treturn this.updateBoundaries()\r\n\t\t\t\t.then(() => {\r\n\t\t\t\t\tif (this.priority !== 'visible-area') {\r\n\t\t\t\t\t\tthis.visibleArea = null;\r\n\t\t\t\t\t\tthis.resetCoordinates();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.visibleArea = isFunction(this.defaultVisibleArea)\r\n\t\t\t\t\t\t? this.defaultVisibleArea({\r\n\t\t\t\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\t\t\t\t\tcoordinates: this.priority !== 'visible-area' ? this.coordinates : null,\r\n\t\t\t\t\t\t\t\tgetAreaRestrictions: this.getAreaRestrictions,\r\n\t\t\t\t\t\t\t\tstencilSize: this.getStencilSize(),\r\n\t\t\t\t\t\t  })\r\n\t\t\t\t\t\t: this.defaultVisibleArea;\r\n\r\n\t\t\t\t\tthis.visibleArea = algorithms.refineVisibleArea({\r\n\t\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\t\t\tgetAreaRestrictions: this.getAreaRestrictions,\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tif (this.priority === 'visible-area') {\r\n\t\t\t\t\t\tthis.resetCoordinates();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.coordinates = this.fitCoordinates({\r\n\t\t\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\t\t\t\taspectRatio: this.getAspectRatio(),\r\n\t\t\t\t\t\t\tpositionRestrictions: this.positionRestrictions,\r\n\t\t\t\t\t\t\tsizeRestrictions: this.sizeRestrictions,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.runAutoZoom('resetVisibleArea');\r\n\t\t\t\t})\r\n\t\t\t\t.catch(() => {\r\n\t\t\t\t\tthis.visibleArea = null;\r\n\t\t\t\t});\r\n\t\t},\r\n\t\tupdateVisibleArea() {\r\n\t\t\treturn this.updateBoundaries()\r\n\t\t\t\t.then(() => {\r\n\t\t\t\t\tthis.visibleArea = this.fitVisibleArea({\r\n\t\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\t\t\tgetAreaRestrictions: this.getAreaRestrictions,\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.coordinates = this.fitCoordinates({\r\n\t\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\t\t\taspectRatio: this.getAspectRatio(),\r\n\t\t\t\t\t\tpositionRestrictions: this.positionRestrictions,\r\n\t\t\t\t\t\tsizeRestrictions: this.sizeRestrictions,\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.runAutoZoom('updateVisibleArea');\r\n\t\t\t\t})\r\n\t\t\t\t.catch(() => {\r\n\t\t\t\t\tthis.visibleArea = null;\r\n\t\t\t\t});\r\n\t\t},\r\n\t\tonChange(debounce = true) {\r\n\t\t\tif (this.$listeners && this.$listeners.change) {\r\n\t\t\t\tif (debounce && this.debounce) {\r\n\t\t\t\t\tthis.debouncedUpdate();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.update();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonChangeImage() {\r\n\t\t\tthis.imageLoaded = false;\r\n\t\t\tthis.delayedTransforms = null;\r\n\r\n\t\t\tif (this.src) {\r\n\t\t\t\tif (isCrossOriginURL(this.src)) {\r\n\t\t\t\t\tlet crossOrigin = isUndefined(this.crossOrigin) ? this.canvas : this.crossOrigin;\r\n\t\t\t\t\tif (crossOrigin === true) {\r\n\t\t\t\t\t\tcrossOrigin = 'anonymous';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.imageAttributes.crossOrigin = crossOrigin;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.checkOrientation) {\r\n\t\t\t\t\tconst promise = parseImage(this.src);\r\n\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\tpromise.then(this.onParseImage);\r\n\t\t\t\t\t}, this.transitionTime);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\tthis.onParseImage({ source: this.src });\r\n\t\t\t\t\t}, this.transitionTime);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.clearImage();\r\n\t\t\t}\r\n\t\t},\r\n\t\tonFailLoadImage() {\r\n\t\t\tif (this.imageAttributes.src) {\r\n\t\t\t\tthis.clearImage();\r\n\t\t\t\tthis.$emit('error');\r\n\t\t\t}\r\n\t\t},\r\n\t\tonSuccessLoadImage() {\r\n\t\t\t// After loading image the current component can be unmounted\r\n\t\t\t// Therefore there is a workaround to prevent processing the following code\r\n\t\t\tconst image = this.$refs.image;\r\n\t\t\tif (image && !this.imageLoaded) {\r\n\t\t\t\tthis.imageAttributes.height = image.naturalHeight;\r\n\t\t\t\tthis.imageAttributes.width = image.naturalWidth;\r\n\t\t\t\tthis.imageLoaded = true;\r\n\t\t\t\tthis.reset().then(() => {\r\n\t\t\t\t\tthis.$emit('ready');\r\n\t\t\t\t\tthis.onChange(false);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\tonParseImage({ source, arrayBuffer, orientation }) {\r\n\t\t\tif (this.imageAttributes.revoke && this.imageAttributes.src) {\r\n\t\t\t\tURL.revokeObjectURL(this.imageAttributes.src);\r\n\t\t\t}\r\n\t\t\tthis.imageAttributes.revoke = false;\r\n\t\t\tif (arrayBuffer && orientation && orientation > 1 && isLocal(source)) {\r\n\t\t\t\tif (isBlob(source)) {\r\n\t\t\t\t\tthis.imageAttributes.src = URL.createObjectURL(new Blob([arrayBuffer]));\r\n\t\t\t\t\tthis.imageAttributes.revoke = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.imageAttributes.src = arrayBufferToDataURL(arrayBuffer);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.imageAttributes.src = source;\r\n\t\t\t}\r\n\t\t\tthis.customImageTransforms = {\r\n\t\t\t\trotate: 0,\r\n\t\t\t\tflip: {\r\n\t\t\t\t\thorizontal: false,\r\n\t\t\t\t\tvertical: false,\r\n\t\t\t\t},\r\n\t\t\t};\r\n\t\t\tthis.basicImageTransforms = {\r\n\t\t\t\t...this.customImageTransforms,\r\n\t\t\t\t...getImageTransforms(orientation),\r\n\t\t\t};\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tconst image = this.$refs.image;\r\n\t\t\t\tif (image && image.complete) {\r\n\t\t\t\t\tif (isLoadedImage(image)) {\r\n\t\t\t\t\t\tthis.onSuccessLoadImage();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.onFailLoadImage();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\tonResizeEnd() {\r\n\t\t\tthis.runAutoZoom('resize', {\r\n\t\t\t\ttransitions: true,\r\n\t\t\t});\r\n\t\t},\r\n\t\tonMoveEnd() {\r\n\t\t\tthis.runAutoZoom('move', {\r\n\t\t\t\ttransitions: true,\r\n\t\t\t});\r\n\t\t},\r\n\t\tonMove(event) {\r\n\t\t\tif (!this.transitionsOptions.enabled) {\r\n\t\t\t\tthis.awaitRender(() => {\r\n\t\t\t\t\tthis.coordinates = this.moveAlgorithm({\r\n\t\t\t\t\t\t...this.getPublicProperties(),\r\n\t\t\t\t\t\tpositionRestrictions: algorithms.limitBy(this.positionRestrictions, this.visibleArea),\r\n\t\t\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\t\t\tevent: this.normalizeEvent(event),\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.onChange();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\tonResize(event) {\r\n\t\t\tif (!this.transitionsOptions.enabled && (!this.stencilSize || this.autoZoom)) {\r\n\t\t\t\tthis.awaitRender(() => {\r\n\t\t\t\t\tconst sizeRestrictions = this.sizeRestrictions;\r\n\r\n\t\t\t\t\t// The magic number is the approximation of the handler size\r\n\t\t\t\t\t// Temporary solution that should be improved in the future\r\n\t\t\t\t\tconst minimumSize = Math.min(\r\n\t\t\t\t\t\tthis.coordinates.width,\r\n\t\t\t\t\t\tthis.coordinates.height,\r\n\t\t\t\t\t\t20 * this.coefficient,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tthis.coordinates = this.resizeAlgorithm({\r\n\t\t\t\t\t\t...this.getPublicProperties(),\r\n\t\t\t\t\t\tpositionRestrictions: algorithms.limitBy(this.positionRestrictions, this.visibleArea),\r\n\t\t\t\t\t\tsizeRestrictions: {\r\n\t\t\t\t\t\t\tmaxWidth: Math.min(sizeRestrictions.maxWidth, this.visibleArea.width),\r\n\t\t\t\t\t\t\tmaxHeight: Math.min(sizeRestrictions.maxHeight, this.visibleArea.height),\r\n\t\t\t\t\t\t\tminWidth: Math.max(sizeRestrictions.minWidth, minimumSize),\r\n\t\t\t\t\t\t\tminHeight: Math.max(sizeRestrictions.minHeight, minimumSize),\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tevent: this.normalizeEvent(event),\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.onChange();\r\n\t\t\t\t\tthis.ticking = false;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\tonManipulateImage(event, params = {}) {\r\n\t\t\tif (!this.transitionsOptions.enabled) {\r\n\t\t\t\tconst { transitions = false, normalize = true } = params;\r\n\t\t\t\tif (transitions) {\r\n\t\t\t\t\tthis.enableTransitions();\r\n\t\t\t\t}\r\n\t\t\t\tconst { visibleArea, coordinates } = algorithms.manipulateImage({\r\n\t\t\t\t\t...this.getPublicProperties(),\r\n\t\t\t\t\tevent: normalize ? this.normalizeEvent(event) : event,\r\n\t\t\t\t\tgetAreaRestrictions: this.getAreaRestrictions,\r\n\t\t\t\t\timageRestriction: this.imageRestriction,\r\n\t\t\t\t\tadjustStencil: !this.stencilSize && this.settings.resizeImage.adjustStencil,\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.visibleArea = visibleArea;\r\n\t\t\t\tthis.coordinates = coordinates;\r\n\r\n\t\t\t\tthis.runAutoZoom('manipulateImage');\r\n\r\n\t\t\t\tthis.onChange();\r\n\r\n\t\t\t\tif (transitions) {\r\n\t\t\t\t\tthis.debouncedDisableTransitions();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonPropsChange() {\r\n\t\t\tthis.coordinates = this.applyTransform(this.coordinates, true);\r\n\t\t\tthis.onChange(false);\r\n\t\t},\r\n\t\tgetAreaRestrictions({ visibleArea, type = 'move' } = {}) {\r\n\t\t\treturn this.areaRestrictionsAlgorithm({\r\n\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\timageRestriction: this.imageRestriction,\r\n\t\t\t\tvisibleArea,\r\n\t\t\t\ttype,\r\n\t\t\t});\r\n\t\t},\r\n\t\tgetAspectRatio(ignoreStencil) {\r\n\t\t\tlet minimum, maximum;\r\n\t\t\tconst { aspectRatio, minAspectRatio, maxAspectRatio } = this.stencilProps;\r\n\r\n\t\t\tif (this.$refs.stencil.aspectRatios) {\r\n\t\t\t\t({ minimum, maximum } = this.$refs.stencil.aspectRatios());\r\n\t\t\t}\r\n\r\n\t\t\tif (isUndefined(minimum)) {\r\n\t\t\t\tminimum = !isUndefined(aspectRatio) ? aspectRatio : minAspectRatio;\r\n\t\t\t}\r\n\t\t\tif (isUndefined(maximum)) {\r\n\t\t\t\tmaximum = !isUndefined(aspectRatio) ? aspectRatio : maxAspectRatio;\r\n\t\t\t}\r\n\r\n\t\t\tif (!ignoreStencil && (isUndefined(minimum) || isUndefined(maximum))) {\r\n\t\t\t\tconst stencilSize = this.getStencilSize();\r\n\t\t\t\tconst stencilRatio = stencilSize ? ratio(stencilSize) : null;\r\n\t\t\t\tif (isUndefined(minimum)) {\r\n\t\t\t\t\tminimum = isNumber(stencilRatio) ? stencilRatio : undefined;\r\n\t\t\t\t}\r\n\t\t\t\tif (isUndefined(maximum)) {\r\n\t\t\t\t\tmaximum = isNumber(stencilRatio) ? stencilRatio : undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tminimum,\r\n\t\t\t\tmaximum,\r\n\t\t\t};\r\n\t\t},\r\n\t\tgetStencilSize() {\r\n\t\t\tif (this.stencilSize) {\r\n\t\t\t\treturn algorithms.calculateStencilSize({\r\n\t\t\t\t\tcurrentStencilSize: {\r\n\t\t\t\t\t\twidth: this.stencilCoordinates.width,\r\n\t\t\t\t\t\theight: this.stencilCoordinates.height,\r\n\t\t\t\t\t},\r\n\t\t\t\t\tstencilSize: this.stencilSize,\r\n\t\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\t\tcoefficient: this.coefficient,\r\n\t\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\t\taspectRatio: this.getAspectRatio(true),\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetPublicProperties() {\r\n\t\t\treturn {\r\n\t\t\t\tcoefficient: this.coefficient,\r\n\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\tboundaries: this.boundaries,\r\n\t\t\t\tsizeRestrictions: this.sizeRestrictions,\r\n\t\t\t\tpositionRestrictions: this.positionRestrictions,\r\n\t\t\t\taspectRatio: this.getAspectRatio(),\r\n\t\t\t\timageRestriction: this.imageRestriction,\r\n\t\t\t};\r\n\t\t},\r\n\t\tdefaultCoordinates() {\r\n\t\t\treturn { ...DEFAULT_COORDINATES };\r\n\t\t},\r\n\t\tflip(horizontal, vertical, options = {}) {\r\n\t\t\tconst { transitions = true } = options;\r\n\t\t\tif (!this.transitionsActive) {\r\n\t\t\t\tif (transitions) {\r\n\t\t\t\t\tthis.enableTransitions();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst previousFlip = {\r\n\t\t\t\t\t...this.imageTransforms.flip,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tlet { visibleArea, coordinates } = algorithms.flipImage({\r\n\t\t\t\t\tflip: {\r\n\t\t\t\t\t\thorizontal: horizontal ? !previousFlip.horizontal : previousFlip.horizontal,\r\n\t\t\t\t\t\tvertical: vertical ? !previousFlip.vertical : previousFlip.vertical,\r\n\t\t\t\t\t},\r\n\t\t\t\t\tpreviousFlip,\r\n\t\t\t\t\trotate: this.imageTransforms.rotate,\r\n\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\tpositionRestrictions: this.positionRestrictions,\r\n\t\t\t\t\tsizeRestrictions: this.sizeRestrictions,\r\n\t\t\t\t\tgetAreaRestrictions: this.getAreaRestrictions,\r\n\t\t\t\t\taspectRatio: this.getAspectRatio(),\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (horizontal) {\r\n\t\t\t\t\tthis.customImageTransforms.flip.horizontal = !this.customImageTransforms.flip.horizontal;\r\n\t\t\t\t}\r\n\t\t\t\tif (vertical) {\r\n\t\t\t\t\tthis.customImageTransforms.flip.vertical = !this.customImageTransforms.flip.vertical;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.visibleArea = visibleArea;\r\n\t\t\t\tthis.coordinates = coordinates;\r\n\r\n\t\t\t\tthis.onChange();\r\n\t\t\t\tif (transitions) {\r\n\t\t\t\t\tthis.debouncedDisableTransitions();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\trotate(angle, options = {}) {\r\n\t\t\tconst { transitions = true } = options;\r\n\r\n\t\t\tif (!this.transitionsActive) {\r\n\t\t\t\tif (transitions) {\r\n\t\t\t\t\tthis.enableTransitions();\r\n\t\t\t\t}\r\n\t\t\t\tconst previousImageSize = { ...this.imageSize };\r\n\r\n\t\t\t\tthis.customImageTransforms.rotate += angle;\r\n\t\t\t\tlet { visibleArea, coordinates } = algorithms.rotateImage({\r\n\t\t\t\t\tvisibleArea: this.visibleArea,\r\n\t\t\t\t\tcoordinates: this.coordinates,\r\n\t\t\t\t\tpreviousImageSize,\r\n\t\t\t\t\timageSize: this.imageSize,\r\n\t\t\t\t\tangle,\r\n\t\t\t\t\tpositionRestrictions: this.positionRestrictions,\r\n\t\t\t\t\tsizeRestrictions: this.sizeRestrictions,\r\n\t\t\t\t\tgetAreaRestrictions: this.getAreaRestrictions,\r\n\t\t\t\t\taspectRatio: this.getAspectRatio(),\r\n\t\t\t\t});\r\n\r\n\t\t\t\t({ visibleArea, coordinates } = this.processAutoZoom('rotateImage', visibleArea, coordinates));\r\n\r\n\t\t\t\tthis.visibleArea = visibleArea;\r\n\t\t\t\tthis.coordinates = coordinates;\r\n\r\n\t\t\t\tthis.onChange();\r\n\r\n\t\t\t\tif (transitions) {\r\n\t\t\t\t\tthis.debouncedDisableTransitions();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t},\r\n};\r\n</script>\r\n\r\n<template>\r\n\t<div ref=\"cropper\" :class=\"classes.cropper\">\r\n\t\t<div ref=\"stretcher\" :class=\"classes.stretcher\" />\r\n\r\n\t\t<div :class=\"classes.boundaries\" :style=\"boundariesStyle\">\r\n\t\t\t<cropper-wrapper\r\n\t\t\t\t:class=\"classes.cropperWrapper\"\r\n\t\t\t\t:wheel-resize=\"settings.resizeImage.wheel\"\r\n\t\t\t\t:touch-resize=\"settings.resizeImage.touch\"\r\n\t\t\t\t:touch-move=\"settings.moveImage.touch\"\r\n\t\t\t\t:mouse-move=\"settings.moveImage.mouse\"\r\n\t\t\t\t@move=\"onManipulateImage\"\r\n\t\t\t\t@resize=\"onManipulateImage\"\r\n\t\t\t>\r\n\t\t\t\t<div :class=\"classes.background\" :style=\"boundariesStyle\"></div>\r\n\t\t\t\t<div :class=\"classes.imageWrapper\">\r\n\t\t\t\t\t<img\r\n\t\t\t\t\t\tref=\"image\"\r\n\t\t\t\t\t\t:crossorigin=\"imageAttributes.crossOrigin\"\r\n\t\t\t\t\t\t:src=\"imageAttributes.src\"\r\n\t\t\t\t\t\t:class=\"classes.image\"\r\n\t\t\t\t\t\t:style=\"imageStyle\"\r\n\t\t\t\t\t\t@mousedown.prevent\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div :class=\"classes.foreground\" :style=\"boundariesStyle\"></div>\r\n\t\t\t\t<component\r\n\t\t\t\t\t:is=\"stencilComponent\"\r\n\t\t\t\t\tv-show=\"imageLoaded\"\r\n\t\t\t\t\tref=\"stencil\"\r\n\t\t\t\t\t:image=\"image\"\r\n\t\t\t\t\t:coordinates=\"coordinates\"\r\n\t\t\t\t\t:stencil-coordinates=\"stencilCoordinates\"\r\n\t\t\t\t\t:transitions=\"transitionsOptions\"\r\n\t\t\t\t\tv-bind=\"stencilProps\"\r\n\t\t\t\t\t@resize=\"onResize\"\r\n\t\t\t\t\t@resize-end=\"onResizeEnd\"\r\n\t\t\t\t\t@move=\"onMove\"\r\n\t\t\t\t\t@move-end=\"onMoveEnd\"\r\n\t\t\t\t/>\r\n\t\t\t\t<canvas v-if=\"canvas\" ref=\"canvas\" :style=\"{ display: 'none' }\" />\r\n\t\t\t\t<canvas v-if=\"canvas\" ref=\"sourceCanvas\" :style=\"{ display: 'none' }\" />\r\n\t\t\t</cropper-wrapper>\r\n\t\t</div>\r\n\t</div>\r\n</template>\r\n\r\n<style lang=\"scss\">\r\n.vue-advanced-cropper {\r\n\ttext-align: center;\r\n\tposition: relative;\r\n\tuser-select: none;\r\n\tmax-height: 100%;\r\n\tmax-width: 100%;\r\n\tdirection: ltr;\r\n\r\n\t&__stretcher {\r\n\t\tpointer-events: none;\r\n\t\tposition: relative;\r\n\t\tmax-width: 100%;\r\n\t\tmax-height: 100%;\r\n\t}\r\n\r\n\t&__image {\r\n\t\tuser-select: none;\r\n\t\tposition: absolute;\r\n\t\ttransform-origin: center;\r\n\t\t// Workaround to prevent bugs at the websites with max-width\r\n\t\t// rule applied to img (Vuepress for example)\r\n\t\tmax-width: none !important;\r\n\t}\r\n\t&__background,\r\n\t&__foreground {\r\n\t\topacity: 1;\r\n\t\tbackground: black;\r\n\t\ttransform: translate(-50%, -50%);\r\n\t\tposition: absolute;\r\n\t\ttop: 50%;\r\n\t\tleft: 50%;\r\n\t}\r\n\t&__foreground {\r\n\t\topacity: 0.5;\r\n\t}\r\n\t&__boundaries {\r\n\t\topacity: 1;\r\n\t\ttransform: translate(-50%, -50%);\r\n\t\tposition: absolute;\r\n\t\tleft: 50%;\r\n\t\ttop: 50%;\r\n\t}\r\n\t&__cropper-wrapper {\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t}\r\n\t&__image-wrapper {\r\n\t\toverflow: hidden;\r\n\t\tposition: absolute;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t}\r\n\t&__stencil-wrapper {\r\n\t\tposition: absolute;\r\n\t}\r\n}\r\n</style>\r\n","import { ImageSize, Point, Size, VisibleArea } from '../typings';\r\n\r\nexport interface DefaultPositionParams {\r\n\tcoordinates: Size;\r\n\timageSize?: ImageSize;\r\n\tvisibleArea?: VisibleArea;\r\n}\r\nexport function defaultPosition({ imageSize, visibleArea, coordinates }: DefaultPositionParams): Point {\r\n\tconst area = visibleArea || imageSize;\r\n\r\n\treturn {\r\n\t\tleft: (visibleArea ? visibleArea.left : 0) + area.width / 2 - coordinates.width / 2,\r\n\t\ttop: (visibleArea ? visibleArea.top : 0) + area.height / 2 - coordinates.height / 2,\r\n\t};\r\n}\r\n","import { Size, VisibleArea, Coordinates, GetAreaRestrictions, Limits, Falsy } from '../typings';\r\nimport { ratio, toLimits, intersectionLimits, fitToLimits, getIntersections, fitSize, limitsToSize } from '../service';\r\n\r\nexport interface DefaultVisibleAreaParams {\r\n\timageSize: Size;\r\n\tboundaries: Size;\r\n\tcoordinates?: Coordinates | Falsy;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n}\r\nexport function defaultVisibleArea(params: DefaultVisibleAreaParams): VisibleArea {\r\n\tconst { getAreaRestrictions, coordinates, imageSize, boundaries } = params;\r\n\r\n\tconst boundaryRatio = ratio(boundaries);\r\n\r\n\tif (coordinates) {\r\n\t\t// Visible area will try to fit reference:\r\n\t\tconst reference = {\r\n\t\t\theight: Math.max(coordinates.height, imageSize.height),\r\n\t\t\twidth: Math.max(coordinates.width, imageSize.width),\r\n\t\t};\r\n\r\n\t\tconst areaProperties = fitSize(\r\n\t\t\t{\r\n\t\t\t\twidth: ratio(reference) > boundaryRatio ? reference.width : reference.height * boundaryRatio,\r\n\t\t\t\theight: ratio(reference) > boundaryRatio ? reference.width / boundaryRatio : reference.height,\r\n\t\t\t},\r\n\t\t\tlimitsToSize(getAreaRestrictions()),\r\n\t\t);\r\n\r\n\t\t// Visible area will try to center stencil:\r\n\t\tconst visibleArea = {\r\n\t\t\tleft: coordinates.left + coordinates.width / 2 - areaProperties.width / 2,\r\n\t\t\ttop: coordinates.top + coordinates.height / 2 - areaProperties.height / 2,\r\n\t\t\twidth: areaProperties.width,\r\n\t\t\theight: areaProperties.height,\r\n\t\t};\r\n\r\n\t\t// TODO: Controversial behavior:\r\n\t\t// If the coordinates are beyond image visible area will be allowed to be beyond image alike:\r\n\t\tconst coordinatesIntersection = getIntersections(\r\n\t\t\tcoordinates,\r\n\t\t\ttoLimits({\r\n\t\t\t\tleft: 0,\r\n\t\t\t\ttop: 0,\r\n\t\t\t\t...imageSize,\r\n\t\t\t}),\r\n\t\t);\r\n\r\n\t\tconst limits: Limits = {};\r\n\r\n\t\tif (!coordinatesIntersection.left && !coordinatesIntersection.right && visibleArea.width <= imageSize.width) {\r\n\t\t\tlimits.left = 0;\r\n\t\t\tlimits.right = imageSize.width;\r\n\t\t}\r\n\r\n\t\tif (!coordinatesIntersection.top && !coordinatesIntersection.bottom && visibleArea.height <= imageSize.height) {\r\n\t\t\tlimits.top = 0;\r\n\t\t\tlimits.bottom = imageSize.height;\r\n\t\t}\r\n\r\n\t\treturn fitToLimits(visibleArea, limits);\r\n\t} else {\r\n\t\tconst imageRatio = ratio(imageSize);\r\n\r\n\t\tconst areaProperties = {\r\n\t\t\theight: imageRatio > boundaryRatio ? imageSize.height : imageSize.width / boundaryRatio,\r\n\t\t\twidth: imageRatio > boundaryRatio ? imageSize.height * boundaryRatio : imageSize.width,\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tleft: imageSize.width / 2 - areaProperties.width / 2,\r\n\t\t\ttop: imageSize.height / 2 - areaProperties.height / 2,\r\n\t\t\twidth: areaProperties.width,\r\n\t\t\theight: areaProperties.height,\r\n\t\t};\r\n\t}\r\n}\r\n","import { Size } from '../typings';\r\nimport { ratio } from '../service';\r\n\r\nexport interface InitStretcherParams {\r\n\tstretcher: HTMLElement;\r\n\timageSize: Size;\r\n}\r\nexport function initStretcher({ stretcher, imageSize }: InitStretcherParams): void {\r\n\tconst aspectRatio = ratio(imageSize);\r\n\tstretcher.style.width = `${imageSize.width}px`;\r\n\tstretcher.style.height = `${stretcher.clientWidth / aspectRatio}px`;\r\n\t// Prevent stretching in future until stretcher will be reinitialized\r\n\tstretcher.style.width = `${stretcher.clientWidth}px`;\r\n}\r\n","import { AspectRatio, Coordinates, PositionRestrictions, SizeRestrictions, VisibleArea } from '../typings';\r\nimport { approximatedSize } from './approximatedSize';\r\nimport { applyMove, diff, fit, fitToLimits, getCenter, intersectionLimits, toLimits } from '../service';\r\n\r\nexport interface FitCoordinatesParams {\r\n\tvisibleArea: VisibleArea;\r\n\tcoordinates: Coordinates;\r\n\taspectRatio: AspectRatio;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n}\r\n\r\nexport function fitCoordinates(params: FitCoordinatesParams): Coordinates {\r\n\tconst {\r\n\t\tvisibleArea,\r\n\t\tcoordinates: previousCoordinates,\r\n\t\taspectRatio,\r\n\t\tsizeRestrictions,\r\n\t\tpositionRestrictions,\r\n\t} = params;\r\n\r\n\tlet coordinates = {\r\n\t\t...previousCoordinates,\r\n\t\t...approximatedSize({\r\n\t\t\twidth: previousCoordinates.width,\r\n\t\t\theight: previousCoordinates.height,\r\n\t\t\taspectRatio,\r\n\t\t\tsizeRestrictions: {\r\n\t\t\t\tmaxWidth: visibleArea.width,\r\n\t\t\t\tmaxHeight: visibleArea.height,\r\n\t\t\t\tminHeight: Math.min(visibleArea.height, sizeRestrictions.minHeight),\r\n\t\t\t\tminWidth: Math.min(visibleArea.width, sizeRestrictions.minWidth),\r\n\t\t\t},\r\n\t\t}),\r\n\t};\r\n\r\n\tcoordinates = applyMove(coordinates, diff(getCenter(previousCoordinates), getCenter(coordinates)));\r\n\r\n\tcoordinates = fitToLimits(coordinates, intersectionLimits(toLimits(visibleArea), positionRestrictions));\r\n\r\n\treturn coordinates;\r\n}\r\n","import {\r\n\tadjustSize,\r\n\tapplyMove,\r\n\tapplyScale,\r\n\tfit,\r\n\tfitToLimits,\r\n\tgetIntersections,\r\n\tinverseMove,\r\n\tmaxScale,\r\n\tratio,\r\n\ttoLimits,\r\n} from '../service';\r\nimport { Coordinates, AreaRestrictions, VisibleArea, Boundaries, GetAreaRestrictions } from '../typings';\r\n\r\n// This function updates visible area with respect to current transformations and fits\r\n// coordinates to the new visible area\r\nexport interface FitVisibleAreaParams {\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n\tcoordinates: Coordinates;\r\n\tvisibleArea: VisibleArea;\r\n\tboundaries: Boundaries;\r\n}\r\nexport function fitVisibleArea(params: FitVisibleAreaParams): VisibleArea {\r\n\tconst { visibleArea: previousVisibleArea, boundaries, getAreaRestrictions, coordinates } = params;\r\n\r\n\tlet visibleArea = { ...previousVisibleArea };\r\n\r\n\t// Scale visible area size to fit new boundaries:\r\n\tvisibleArea.height = visibleArea.width / ratio(boundaries);\r\n\tvisibleArea.top += (previousVisibleArea.height - visibleArea.height) / 2;\r\n\r\n\t// Scale visible area to prevent overlap coordinates\r\n\tif (coordinates.height - visibleArea.height > 0 || coordinates.width - visibleArea.width > 0) {\r\n\t\tvisibleArea = applyScale(\r\n\t\t\tvisibleArea,\r\n\t\t\tMath.max(coordinates.height / visibleArea.height, coordinates.width / visibleArea.width),\r\n\t\t);\r\n\t}\r\n\r\n\t// Scale visible area to prevent overlap area restrictions\r\n\tvisibleArea = applyScale(\r\n\t\tvisibleArea,\r\n\t\tadjustSize(visibleArea, getAreaRestrictions({ visibleArea, type: 'resize' })),\r\n\t);\r\n\r\n\t// Move visible are to prevent moving of the coordinates:\r\n\tconst move = inverseMove(fit(coordinates, toLimits(visibleArea)));\r\n\tif (visibleArea.width < coordinates.width) {\r\n\t\tmove.left = 0;\r\n\t}\r\n\tif (visibleArea.height < coordinates.height) {\r\n\t\tmove.top = 0;\r\n\t}\r\n\tvisibleArea = applyMove(visibleArea, move);\r\n\r\n\t// Move visible area to prevent overlap the area restrictions\r\n\tvisibleArea = fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n\r\n\treturn visibleArea;\r\n}\r\n","import { Boundaries, ImageRestriction, Limits, Size, VisibleArea } from '../typings';\r\nimport { ratio } from '../service';\r\n\r\nexport interface DynamicAreaRestrictionsParams {\r\n\timageRestriction: ImageRestriction;\r\n\timageSize: Size;\r\n\tboundaries: Boundaries;\r\n\tvisibleArea?: VisibleArea;\r\n\tcenter?: boolean;\r\n\ttype: 'resize' | 'move';\r\n}\r\nexport function dynamicAreaRestrictions(params: DynamicAreaRestrictionsParams): Limits {\r\n\tconst { visibleArea, boundaries, imageSize, imageRestriction, type } = params;\r\n\r\n\tlet limits: Limits = {};\r\n\r\n\tif (imageRestriction === 'fill-area') {\r\n\t\tlimits = {\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t\tright: imageSize.width,\r\n\t\t\tbottom: imageSize.height,\r\n\t\t};\r\n\t} else if (imageRestriction === 'fit-area') {\r\n\t\tif (ratio(boundaries) > ratio(imageSize)) {\r\n\t\t\tlimits = {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tbottom: imageSize.height,\r\n\t\t\t};\r\n\t\t\tif (visibleArea && type === 'move') {\r\n\t\t\t\tif (visibleArea.width > imageSize.width) {\r\n\t\t\t\t\tlimits.left = -(visibleArea.width - imageSize.width) / 2;\r\n\t\t\t\t\tlimits.right = imageSize.width - limits.left;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlimits.left = 0;\r\n\t\t\t\t\tlimits.right = imageSize.width;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlimits = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: imageSize.width,\r\n\t\t\t};\r\n\t\t\tif (visibleArea && type === 'move') {\r\n\t\t\t\tif (visibleArea.height > imageSize.height) {\r\n\t\t\t\t\tlimits.top = -(visibleArea.height - imageSize.height) / 2;\r\n\t\t\t\t\tlimits.bottom = imageSize.height - limits.top;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlimits.top = 0;\r\n\t\t\t\t\tlimits.bottom = imageSize.height;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn limits;\r\n}\r\n","import { Size, SizeRestrictions } from '../typings';\r\n\r\nexport interface SizeRestrictionsParams {\r\n\timageSize: Size;\r\n\tminWidth: number;\r\n\tminHeight: number;\r\n\tmaxWidth: number;\r\n\tmaxHeight: number;\r\n}\r\nexport function percentRestrictions({\r\n\timageSize,\r\n\tminWidth,\r\n\tminHeight,\r\n\tmaxWidth,\r\n\tmaxHeight,\r\n}: SizeRestrictionsParams): SizeRestrictions {\r\n\treturn {\r\n\t\tminWidth: (minWidth / 100) * imageSize.width,\r\n\t\tminHeight: (minHeight / 100) * imageSize.height,\r\n\t\tmaxWidth: (maxWidth / 100) * imageSize.width,\r\n\t\tmaxHeight: (maxHeight / 100) * imageSize.height,\r\n\t};\r\n}\r\n\r\nexport function pixelsRestrictions({\r\n\tminWidth,\r\n\tminHeight,\r\n\tmaxWidth,\r\n\tmaxHeight,\r\n}: SizeRestrictionsParams): SizeRestrictions {\r\n\treturn {\r\n\t\tminWidth,\r\n\t\tminHeight,\r\n\t\tmaxWidth,\r\n\t\tmaxHeight,\r\n\t};\r\n}\r\n","import { ImageRestriction, Limits, Size } from '../typings';\r\n\r\nexport interface PositionRestrictionsParams {\r\n\timageRestriction: ImageRestriction;\r\n\timageSize: Size;\r\n}\r\nexport function positionRestrictions({ imageSize, imageRestriction }: PositionRestrictionsParams): Limits {\r\n\tlet limits = {};\r\n\r\n\tif (imageRestriction !== 'none') {\r\n\t\tlimits = {\r\n\t\t\tleft: 0,\r\n\t\t\ttop: 0,\r\n\t\t\tright: imageSize.width,\r\n\t\t\tbottom: imageSize.height,\r\n\t\t};\r\n\t}\r\n\r\n\treturn limits;\r\n}\r\n","import {\r\n\tAreaRestrictions,\r\n\tBoundaries,\r\n\tImageRestriction,\r\n\tPositionRestrictions,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tVisibleArea,\r\n} from '../typings';\r\nimport { fitSize, limitsToSize } from '../service';\r\nimport { isUndefined } from '../utils';\r\n\r\ninterface RefineSizeRestrictionsParams {\r\n\tsizeRestrictions: Partial<SizeRestrictions>;\r\n\tareaRestrictions: AreaRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n\tboundaries: Boundaries;\r\n\timageSize: Size;\r\n\timageRestriction: ImageRestriction;\r\n}\r\nexport function refineSizeRestrictions({\r\n\tareaRestrictions,\r\n\tsizeRestrictions,\r\n\timageSize,\r\n\tboundaries,\r\n\tpositionRestrictions,\r\n\timageRestriction = 'none',\r\n}: RefineSizeRestrictionsParams) {\r\n\t// User can forget to set some of restrictions, so we should init them by default values\r\n\tconst restrictions = {\r\n\t\t...sizeRestrictions,\r\n\t\tminWidth: sizeRestrictions.minWidth !== undefined ? sizeRestrictions.minWidth : 0,\r\n\t\tminHeight: sizeRestrictions.minHeight !== undefined ? sizeRestrictions.minHeight : 0,\r\n\t\tmaxWidth: sizeRestrictions.maxWidth !== undefined ? sizeRestrictions.maxWidth : Infinity,\r\n\t\tmaxHeight: sizeRestrictions.maxHeight !== undefined ? sizeRestrictions.maxHeight : Infinity,\r\n\t};\r\n\r\n\t// The situation, when stencil can't be positioned in cropper due to positionRestrictions should be avoided\r\n\tif (positionRestrictions.left !== undefined && positionRestrictions.right !== undefined) {\r\n\t\trestrictions.maxWidth = Math.min(restrictions.maxWidth, positionRestrictions.right - positionRestrictions.left);\r\n\t}\r\n\tif (positionRestrictions.bottom !== undefined && positionRestrictions.top !== undefined) {\r\n\t\trestrictions.maxHeight = Math.min(\r\n\t\t\trestrictions.maxHeight,\r\n\t\t\tpositionRestrictions.bottom - positionRestrictions.top,\r\n\t\t);\r\n\t}\r\n\r\n\t// The situation when stencil larger than maximum visible area or image should be avoided if imageRestriction != 'none':\r\n\tconst areaLimits = limitsToSize(areaRestrictions);\r\n\tconst areaMaximum = fitSize(boundaries, areaLimits);\r\n\r\n\tif (areaLimits.width < Infinity && (!restrictions.maxWidth || restrictions.maxWidth > areaMaximum.width)) {\r\n\t\trestrictions.maxWidth = Math.min(restrictions.maxWidth, areaMaximum.width);\r\n\t}\r\n\tif (areaLimits.height < Infinity && (!restrictions.maxHeight || restrictions.maxHeight > areaMaximum.height)) {\r\n\t\trestrictions.maxHeight = Math.min(restrictions.maxHeight, areaMaximum.height);\r\n\t}\r\n\r\n\t// Process the border cases when minimum height / width larger than maximum height / width\r\n\tif (restrictions.minWidth > restrictions.maxWidth) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.warn(\r\n\t\t\t\t`Warning: maximum width (${restrictions.maxWidth}px) fewer that the minimum width (${restrictions.minWidth}px). It is set equal to the minimum width and width resizing was blocked`,\r\n\t\t\t);\r\n\t\t}\r\n\t\trestrictions.minWidth = restrictions.maxWidth;\r\n\t\trestrictions.widthFrozen = true;\r\n\t}\r\n\r\n\tif (restrictions.minHeight > restrictions.maxHeight) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.warn(\r\n\t\t\t\t`Warning: maximum height (${restrictions.maxHeight}px) fewer that the minimum height (${restrictions.minHeight}px). It is set equal to the minimum height and height resizing was blocked`,\r\n\t\t\t);\r\n\t\t}\r\n\t\trestrictions.minHeight = restrictions.maxHeight;\r\n\t\trestrictions.heightFrozen = true;\r\n\t}\r\n\r\n\treturn restrictions;\r\n}\r\n","import { Coordinates, PositionRestrictions, SizeRestrictions } from '../typings';\r\nimport { fitToLimits } from '../service';\r\n\r\nexport interface RoundCoordinatesParams {\r\n\tcoordinates: Coordinates;\r\n\tsizeRestrictions: SizeRestrictions;\r\n\tpositionRestrictions: PositionRestrictions;\r\n}\r\nexport function roundCoordinates({\r\n\tcoordinates,\r\n\tsizeRestrictions,\r\n\tpositionRestrictions,\r\n}: RoundCoordinatesParams): Coordinates {\r\n\tconst roundedCoordinates = {\r\n\t\twidth: Math.round(coordinates.width),\r\n\t\theight: Math.round(coordinates.height),\r\n\t\tleft: Math.round(coordinates.left),\r\n\t\ttop: Math.round(coordinates.top),\r\n\t};\r\n\r\n\tif (roundedCoordinates.width > sizeRestrictions.maxWidth) {\r\n\t\troundedCoordinates.width = Math.floor(coordinates.width);\r\n\t} else if (roundedCoordinates.width < sizeRestrictions.minWidth) {\r\n\t\troundedCoordinates.width = Math.ceil(coordinates.width);\r\n\t}\r\n\tif (roundedCoordinates.height > sizeRestrictions.maxHeight) {\r\n\t\troundedCoordinates.height = Math.floor(coordinates.height);\r\n\t} else if (roundedCoordinates.height < sizeRestrictions.minHeight) {\r\n\t\troundedCoordinates.height = Math.ceil(coordinates.height);\r\n\t}\r\n\r\n\treturn fitToLimits(roundedCoordinates, positionRestrictions);\r\n}\r\n","import { ManipulateImageEvent, MoveEvent, ResizeEvent } from '../events';\r\nimport { VisibleArea } from '../typings';\r\nimport { ALL_DIRECTIONS, MAIN_DIRECTIONS } from '../constants';\r\n\r\ninterface NormalizeEventParams {\r\n\tevent: ResizeEvent | MoveEvent | ManipulateImageEvent;\r\n\tvisibleArea: VisibleArea;\r\n\tcoefficient: number;\r\n}\r\nexport function normalizeEvent({ event, visibleArea, coefficient }: NormalizeEventParams) {\r\n\tif (event.type === 'manipulateImage') {\r\n\t\treturn {\r\n\t\t\t...event,\r\n\t\t\tmove: {\r\n\t\t\t\tleft: event.move && event.move.left ? coefficient * event.move.left : 0,\r\n\t\t\t\ttop: event.move && event.move.top ? coefficient * event.move.top : 0,\r\n\t\t\t},\r\n\t\t\tscale: {\r\n\t\t\t\tfactor: event.scale && event.scale.factor ? event.scale.factor : 1,\r\n\t\t\t\tcenter:\r\n\t\t\t\t\tevent.scale && event.scale.center\r\n\t\t\t\t\t\t? {\r\n\t\t\t\t\t\t\t\tleft: event.scale.center.left * coefficient + visibleArea.left,\r\n\t\t\t\t\t\t\t\ttop: event.scale.center.top * coefficient + visibleArea.top,\r\n\t\t\t\t\t\t  }\r\n\t\t\t\t\t\t: null,\r\n\t\t\t},\r\n\t\t};\r\n\t} else if (event.type === 'resize') {\r\n\t\tconst normalizedEvent = { ...event, directions: { ...event.directions } };\r\n\t\tALL_DIRECTIONS.forEach((direction) => {\r\n\t\t\tnormalizedEvent.directions[direction] *= coefficient;\r\n\t\t});\r\n\t\treturn normalizedEvent;\r\n\t} else if (event.type === 'move') {\r\n\t\tconst normalizedEvent = { ...event, directions: { ...event.directions } };\r\n\t\tMAIN_DIRECTIONS.forEach((direction) => {\r\n\t\t\tnormalizedEvent.directions[direction] *= coefficient;\r\n\t\t});\r\n\t\treturn normalizedEvent;\r\n\t} else {\r\n\t\treturn event;\r\n\t}\r\n}\r\n","import { Coordinates, Size } from './typings';\n\ninterface Options {\n\timageSmoothingQuality?: 'low' | 'medium' | 'high';\n\timageSmoothingEnabled?: boolean;\n\tfillColor?: string;\n}\n\nexport function updateCanvas(\n\tcanvas: HTMLCanvasElement,\n\tsource: HTMLCanvasElement | HTMLImageElement,\n\tcoordinates: Coordinates,\n\tresultSize?: Size,\n\toptions?: Options,\n) {\n\tcanvas.width = resultSize ? resultSize.width : coordinates.width;\n\tcanvas.height = resultSize ? resultSize.height : coordinates.height;\n\n\tconst ctx = canvas.getContext('2d');\n\n\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\n\tif (options) {\n\t\tif (options.imageSmoothingEnabled) {\n\t\t\tctx.imageSmoothingEnabled = options.imageSmoothingEnabled;\n\t\t}\n\t\tif (options.imageSmoothingQuality) {\n\t\t\tctx.imageSmoothingQuality = options.imageSmoothingQuality;\n\t\t}\n\t\tif (options.fillColor) {\n\t\t\tctx.fillStyle = options.fillColor;\n\t\t\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\tctx.save();\n\t\t}\n\t}\n\n\tctx.drawImage(\n\t\tsource,\n\t\tcoordinates.left,\n\t\tcoordinates.top,\n\t\tcoordinates.width,\n\t\tcoordinates.height,\n\t\t0,\n\t\t0,\n\t\tcanvas.width,\n\t\tcanvas.height,\n\t);\n}\n","import { Boundaries, Size } from '../typings';\r\n\r\nexport interface DefaultBoundariesParams {\r\n\tcropper: HTMLElement;\r\n\timageSize: Size;\r\n}\r\n\r\nexport function fitBoundaries({ cropper, imageSize }: DefaultBoundariesParams): Boundaries {\r\n\tconst areaHeight = cropper.clientHeight;\r\n\tconst areaWidth = cropper.clientWidth;\r\n\r\n\tlet currentHeight = areaHeight;\r\n\tlet currentWidth = (imageSize.width * areaHeight) / imageSize.height;\r\n\r\n\tif (currentWidth > areaWidth) {\r\n\t\tcurrentWidth = areaWidth;\r\n\t\tcurrentHeight = (imageSize.height * areaWidth) / imageSize.width;\r\n\t}\r\n\r\n\treturn {\r\n\t\twidth: currentWidth,\r\n\t\theight: currentHeight,\r\n\t};\r\n}\r\n\r\nexport function fillBoundaries({ cropper }: DefaultBoundariesParams): Boundaries {\r\n\treturn {\r\n\t\twidth: cropper.clientWidth,\r\n\t\theight: cropper.clientHeight,\r\n\t};\r\n}\r\n","import { GetAreaRestrictions, Boundaries, VisibleArea } from '../typings';\r\nimport { fitToLimits, ratio } from '../service';\r\n\r\ninterface RefineVisibleAreaParams {\r\n\tvisibleArea: VisibleArea;\r\n\tboundaries: Boundaries;\r\n\tgetAreaRestrictions: GetAreaRestrictions;\r\n}\r\nexport function refineVisibleArea(params: RefineVisibleAreaParams): VisibleArea {\r\n\tconst { visibleArea: previousVisibleArea, boundaries, getAreaRestrictions } = params;\r\n\r\n\tlet visibleArea = { ...previousVisibleArea };\r\n\r\n\tconst boundariesRatio = ratio(boundaries);\r\n\tif (visibleArea.width / visibleArea.height !== boundariesRatio) {\r\n\t\tvisibleArea.height = visibleArea.width / boundariesRatio;\r\n\t}\r\n\r\n\treturn fitToLimits(visibleArea, getAreaRestrictions({ visibleArea, type: 'move' }));\r\n}\r\n","import {\r\n\tAspectRatio,\r\n\tBoundaries,\r\n\tCoordinates,\r\n\tGetAreaRestrictions,\r\n\tPositionRestrictions,\r\n\tSize,\r\n\tSizeRestrictions,\r\n\tStencilSize,\r\n\tPosition,\r\n\tVisibleArea,\r\n\tStencilCalculationParams,\r\n} from '../typings';\r\nimport { isFunction, isUndefined } from '../utils';\r\nimport { adjustSize, applyScale, fitToLimits, getBrokenRatio, intersectionLimits, ratio, toLimits } from '../service';\r\nimport { approximatedSize } from './approximatedSize';\r\n\r\nexport interface CalculateStencilSizeParams {\r\n\taspectRatio: AspectRatio;\r\n\tstencilSize: StencilSize;\r\n\tboundaries: Boundaries;\r\n}\r\nexport function calculateStencilSize(params: CalculateStencilSizeParams): Size {\r\n\tconst { boundaries, stencilSize, aspectRatio } = params;\r\n\r\n\t// Checks that coordinates has the same ratio that coordinates:\r\n\tlet stencil = isFunction(stencilSize)\r\n\t\t? (stencilSize as Function)({ boundaries, aspectRatio })\r\n\t\t: stencilSize;\r\n\r\n\tif (getBrokenRatio(ratio(stencil), aspectRatio)) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`[Adjusting stencil] The aspect ratio of stencil doesn't correspondent to aspect ratio limitations`,\r\n\t\t\t);\r\n\t\t}\r\n\t\tstencil = approximatedSize({\r\n\t\t\tsizeRestrictions: {\r\n\t\t\t\tmaxWidth: boundaries.width,\r\n\t\t\t\tmaxHeight: boundaries.height,\r\n\t\t\t\tminWidth: 0,\r\n\t\t\t\tminHeight: 0,\r\n\t\t\t},\r\n\t\t\twidth: stencil.width,\r\n\t\t\theight: stencil.height,\r\n\t\t\taspectRatio: {\r\n\t\t\t\tminimum: aspectRatio.minimum,\r\n\t\t\t\tmaximum: aspectRatio.maximum,\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\tif (stencil.width > boundaries.width || stencil.height > boundaries.height) {\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`[Adjusting stencil] The width and height of stencil (${stencil.width}, ${stencil.height}) should be fewer or equal to the width and height of boundaries (${boundaries.width},${boundaries.height}) respectively`,\r\n\t\t\t);\r\n\t\t}\r\n\t\tstencil = approximatedSize({\r\n\t\t\tsizeRestrictions: {\r\n\t\t\t\tmaxWidth: boundaries.width,\r\n\t\t\t\tmaxHeight: boundaries.height,\r\n\t\t\t\tminWidth: 0,\r\n\t\t\t\tminHeight: 0,\r\n\t\t\t},\r\n\t\t\twidth: stencil.width,\r\n\t\t\theight: stencil.height,\r\n\t\t\taspectRatio: {\r\n\t\t\t\tminimum: ratio(stencil),\r\n\t\t\t\tmaximum: ratio(stencil),\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\treturn stencil;\r\n}\r\n","import Vue from 'vue';\r\nimport Cropper from './Cropper.vue';\r\n\r\nimport { RectangleStencil, CircleStencil } from './components/stencils';\r\n\r\nimport { SimpleHandler } from './components/handlers';\r\n\r\nimport { SimpleLine } from './components/lines';\r\n\r\nexport {\r\n\tPreviewResult,\r\n\tDraggableArea,\r\n\tBoundingBox,\r\n\tLineWrapper,\r\n\tHandlerWrapper,\r\n\tDraggableElement,\r\n\tStencilPreview,\r\n} from './components/service';\r\n\r\nexport { RectangleStencil, CircleStencil } from './components/stencils';\r\n\r\nexport { SimpleHandler } from './components/handlers';\r\n\r\nexport { SimpleLine } from './components/lines';\r\n\r\nexport { Preview } from './components/helpers';\r\n\r\nexport { ResizeEvent, MoveEvent, DragEvent } from './core/events';\r\n\r\nexport { default as Cropper } from './Cropper.vue';\r\n\r\nVue.component('cropper', Cropper);\r\nVue.component('rectangle-stencil', RectangleStencil);\r\nVue.component('circle-stencil', CircleStencil);\r\nVue.component('simple-handler', SimpleHandler);\r\nVue.component('simple-line', SimpleLine);\r\n"],"names":["hasOwn","hasOwnProperty","classNames","classes","i","arguments","length","arg","argType","push","Array","isArray","inner","apply","key","call","join","module","exports","default","window","componentName","elementOrMods","mods","element","base","Object","keys","reduce","result","name","value","debounce","func","wait","immediate","timeout","args","context","timestamp","later","last","Date","now","setTimeout","debounced","this","callNow","clear","clearTimeout","flush","__assign","assign","t","s","n","p","prototype","directionNames","hDirection","vDirection","classname","toUpperCase","slice","isBlob","url","test","isLocal","isDataUrl","isFunction","obj","constructor","isUndefined","undefined","isObject","getOptions","options","defaultScheme","falseScheme","forEach","Boolean","parseNumber","number","parsedNumber","Number","isNaN","isNumber","isObjectLike","toString","distance","firstPoint","secondPoint","Math","sqrt","pow","x","y","move","scale","type","directions","params","nativeEvent","position","previousPosition","anchor","DragEvent","_a","_b","getBoundingClientRect","left","top","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","render","staticRenderFns","_compiled","functional","_scopeId","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","beforeMount","addEventListener","onMouseUp","passive","onMouseMove","onTouchMove","onTouchEnd","beforeDestroy","removeEventListener","mounted","$refs","draggable","Error","touches","hovered","methods","onMouseOver","$emit","onMouseLeave","onTouchStart","e","cancelable","disabled","initAnchor","mean","touch","clientX","clientY","preventDefault","stopPropagation","processEnd","processMove","onMouseDown","button","fake","right","bottom","event","newTouches","ALL_DIRECTIONS","HORIZONTAL_DIRECTIONS","VERTICAL_DIRECTIONS","MAIN_DIRECTIONS","IMAGE_RESTRICTIONS","DEFAULT_COORDINATES","width","height","isEqual","a","b","properties","some","property","toLimits","object","diff","firstObject","secondObject","getCenter","getIntersections","limits","intersections","direction","areaLimit","objectLimit","max","applyDirections","coordinates","inverseMove","applyMove","applyScale","scaleFactor","center","progress","currentCenter","ratio","maxScale","area","min","Infinity","fit","intersection","getBrokenRatio","currentAspectRatio","aspectRatio","ratioBroken","minimum","maximum","fitSize","firstSize","secondSize","firstRatio","secondRatio","rotateSize","size","angle","radians","PI","abs","cos","sin","rotatePoint","point","adjustSize","fitToLimits","inverse","limitsToSize","limitSizeRestrictions","sizeRestrictions","minWidth","minHeight","maxWidth","maxHeight","joinLimits","firstDirection","secondDirection","intersectionLimits","validateSize","ignoreMinimum","correctRatio","approximatedSize","findBestCandidate","candidates","candidate","positionRestrictions","movedCoordinates","applyTransform","initialCoordinates","transform","imageSize","visibleArea","moveAlgorithm","prevCoordinates","newCoordinates","MoveEvent","changes","resizeAlgorithm","fixedStencilAutoZoom","precision","getAreaRestrictions","boundaries","originalCoordinates","originalVisibleArea","stencilSize","stencil","console","error","hybridStencilAutoZoom","simplestAutoZoom","widthIntersections","heightIntersections","defaultSize","optimalRatio","fixedDefaultSize","limitBy","manipulateImage","adjustStencil","areaScale","stencilScale","allowedScale","factor","scaleRestrictions","relativeCoordinates","rotateImage","previousImageSize","imageCenter","flipImage","flip","previousFlip","rotate","changed","horizontal","vertical","oldCenter","newCenter","fitConditions","preserveRatio","compensate","fittedDirections","currentWidth","currentHeight","breaks","maxResize","multiplier_1","map","multiplier_2","distributeOverlap","overlap","first","second","getImageData","img","Promise","resolve","reject","base64","replace","binary","atob","len","buffer","ArrayBuffer","view","Uint8Array","charCodeAt","base64ToArrayBuffer","fileReader_1","FileReader","onload","target","callback","blob","readAsArrayBuffer","http","XMLHttpRequest","open","responseType","status","response","send","http_1","onreadystatechange","readyState","onprogress","getResponseHeader","abort","withCredentials","getStyleTransforms","scaleX","scaleY","resetAndGetOrientation","arrayBuffer","orientation_1","dataView","DataView","tiffOffset","littleEndian","app1Start","ifdStart","getUint8","length_1","byteLength","offset","start","str","String","fromCharCode","getStringFromCharCode","endianness","getUint16","firstIFDOffset","getUint32","length_2","setUint16","calculateGeometricProperties","container","centerMass","spread","count","boundaryRatio","reference","areaProperties","coordinatesIntersection","imageRatio","actualCoordinates","eventParams","allowedDirections","widthFrozen","heightFrozen","respectDirection","overlapHeight","top_1","overlapWidth","stretcher","clientWidth","previousCoordinates","previousVisibleArea","imageRestriction","areaRestrictions","restrictions","areaLimits","areaMaximum","warn","roundedCoordinates","round","floor","ceil","coefficient","normalizedEvent_1","normalizedEvent_2","canvas","image","originalSize","naturalWidth","naturalHeight","transformedSize","ctx","getContext","save","canvasCenter","translate","drawImage","restore","parseFloat","isFinite","source","resultSize","clearRect","imageSmoothingEnabled","imageSmoothingQuality","fillColor","fillStyle","fillRect","cropper","areaHeight","clientHeight","areaWidth","boundariesRatio","src","pageLocation","location","urlMatch","exec","urlparts","protocol","host","port","portOf","then","data","orientation","catch","chunks","uint8","subarray","from","btoa","Vue","component","Cropper","RectangleStencil","CircleStencil","SimpleHandler","SimpleLine"],"mappings":"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"}